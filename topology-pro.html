<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ARKADU Topology — Organic Terrain with Isomorphic Views</title>
<style>
:root{--void:#0a0e1a;--panel:#0f1419;--grid:#1a3a52;--text:#b8dbd9;--dim:#6b8a96;
--blue:#4dd9cc;--coral:#d97b8f;--amber:#e8b849;--purple:#9d7be8;--green:#6bbd8f}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;background:var(--void);color:var(--text);
font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace}
#wrap{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto}

header{z-index:10;display:flex;gap:10px;align-items:center;padding:10px 12px;
background:linear-gradient(to bottom,rgba(15,20,25,.95),rgba(15,20,25,.75));
border-bottom:1px solid var(--grid);backdrop-filter:blur(8px)}
h1{font-size:14px;color:var(--blue)}
.sub{font-size:11px;color:var(--dim);line-height:1.35}
.spacer{flex:1}
button{font:inherit;font-size:12px;cursor:pointer;color:var(--text);background:transparent;
border:1px solid var(--grid);border-radius:8px;padding:6px 10px;transition:all .2s}
button:hover{border-color:var(--blue);box-shadow:0 0 0 2px rgba(77,217,204,.08) inset}
button.active{background:var(--blue);color:#000}

#legend{position:fixed;right:12px;top:62px;z-index:10;background:rgba(15,20,25,.92);
border:1px solid var(--grid);border-radius:10px;padding:10px 12px;min-width:180px;
backdrop-filter:blur(8px);font-size:11px}
.legend-title{font-size:12px;color:var(--blue);margin-bottom:8px;font-weight:bold}
.row{display:flex;align-items:center;gap:8px;margin:4px 0}
.dot{width:12px;height:12px;border-radius:3px;border:1px solid var(--grid)}

#canvas{display:block;width:100%;height:100%}

.label{position:absolute;font-size:10px;color:var(--blue);font-weight:bold;
pointer-events:none;text-shadow:0 0 4px #000,0 0 8px #000;white-space:nowrap}
.label.kingdom{font-size:13px}
.label.detail{font-size:9px;color:var(--dim)}

footer{z-index:10;display:flex;gap:10px;align-items:center;padding:8px 12px;
background:linear-gradient(to top,rgba(15,20,25,.95),rgba(15,20,25,.55));
border-top:1px solid var(--grid);font-size:11px;color:var(--dim)}

.loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
flex-direction:column;gap:16px;background:var(--void);z-index:200;font-size:13px;color:var(--blue)}
.loading.hidden{display:none}
.progress{width:300px;height:2px;background:rgba(77,217,204,.2);position:relative;overflow:hidden}
.progress-bar{height:100%;background:var(--blue);width:0%;box-shadow:0 0 10px var(--blue);transition:width .3s}
</style>
</head>
<body>
<div id="wrap">
<header>
<h1>ARKADU TOPOLOGY</h1>
<div class="sub">Chambers as organic terrain · Species stratification · Marching squares contours</div>
<div class="spacer"></div>
<button id="btnDepth0">Depth 0</button>
<button id="btnDepth1">Depth 1</button>
<button id="btnDepth2">Depth 2</button>
<button id="btnDepth3">Depth 3</button>
<button id="btnDepth4">Depth 4+</button>
<button id="btnAllDepths" class="active">All Depths</button>
<button id="btnLabels">Labels ON</button>
<button id="btnReset">Reset</button>
</header>
<canvas id="canvas"></canvas>
<footer>
Drag to pan · Scroll to zoom · Click to focus · Scan through depth layers to see all chambers and species · Terrain lies horizontal
</footer>
</div>
<div id="legend"><div class="legend-title">Loading...</div></div>
<div class="loading" id="loading">
<div>⬢ LOADING ARKADU DATA ⬢</div>
<div class="progress"><div class="progress-bar" id="progress"></div></div>
<div id="loadStatus" style="font-size:11px;color:var(--dim)">Initializing...</div>
</div>
<div id="labels"></div>

<script>
(function(){
const CAN=document.getElementById('canvas');
const CTX=CAN.getContext('2d');
let DPR=Math.max(1,window.devicePixelRatio||1);
let W=0,H=0;let zoom=1,panX=0,panY=0;let dragging=false,lastX=0,lastY=0;

const STATE={
chambers:[],mountains:[],
showLabels:true,highlightIdx:-1,filterDepth:null,
thresholds:[0.15,0.30,0.50,0.75],gridStep:8
};

const COLORS={
png:'#4dd9cc',jpg:'#4dd9cc',mp4:'#d97b8f',mp3:'#e8b849',py:'#e8b849',
json:'#9d7be8',html:'#6bbd8f',unknown:'#6b8a96'
};

async function load(){
try{
updateProgress('Loading artifacts...',20);
const r=await fetch('sys/primitive.jsonl');
if(!r.ok)throw new Error(`HTTP ${r.status}: ${r.statusText}`);
const t=await r.text();
const artifacts=t.trim().split('\n').filter(l=>l.trim()).map(l=>JSON.parse(l));

updateProgress('Building chambers...',40);
buildChambers(artifacts);

updateProgress('Generating topology...',70);
generateTopology();

updateProgress('Complete',100);
setTimeout(()=>document.getElementById('loading').classList.add('hidden'),500);

resize();
updateLegend();
}catch(e){
console.error('Load error:',e);
document.getElementById('loadStatus').innerHTML=`<span style="color:var(--coral)">ERROR: ${e.message}</span>`;
}}

function updateProgress(msg,pct){
document.getElementById('loadStatus').textContent=msg.toUpperCase();
document.getElementById('progress').style.width=pct+'%';
}

function buildChambers(artifacts){
const m={};
artifacts.forEach(a=>{
const p=a.path.split('/');
// Build chambers for ALL depths (not just 0-3)
for(let d=1;d<p.length;d++){
const cp=p.slice(0,d).join('/');
if(!m[cp]){
m[cp]={id:cp,name:p[d-1],depth:d-1,parent:d>1?p.slice(0,d-1).join('/'):null,artifacts:[],species:{},totalSize:0};
}
if(d===p.length-1){
m[cp].artifacts.push(a);
const s=(a.ext||'unknown').replace(/^\./);
m[cp].species[s]=(m[cp].species[s]||0)+1;
m[cp].totalSize+=(a.size||0);
}
}
});
// Show ALL chambers (no minimum artifact filter)
STATE.chambers=Object.values(m);
console.log(`Built ${STATE.chambers.length} chambers across ${Math.max(...STATE.chambers.map(c=>c.depth))+1} depth levels`);
}

function generateTopology(){
STATE.mountains=[];
// Create archipelago layout: spiral outward based on depth
STATE.chambers.forEach((ch,idx)=>{
const hash=hashString(ch.id);

// Use depth to determine radial distance (deeper = farther out)
const depthRings=8; // max depth rings
const ringRadius=200;
const baseRadius=150;
const radius=baseRadius+(ch.depth*ringRadius)+(hash%100);

// Angle based on hash + depth offset
const angle=(hash%360)*(Math.PI/180)+(ch.depth*0.3);

const cx=960+Math.cos(angle)*radius;
const cy=540+Math.sin(angle)*radius;

const speciesList=Object.entries(ch.species).sort((a,b)=>b[1]-a[1]);
const speciesLayers=[];

speciesList.forEach(([species,count])=>{
const points=[];
// Scale spread based on count (smaller chambers = smaller mountains)
const spread=Math.max(5,Math.sqrt(count)*2);
// Generate MORE points for better detail (not capped at 150)
const numPoints=Math.min(count,Math.max(20,count*0.8));
for(let i=0;i<numPoints;i++){
const r=gaussianRandom()*spread;
const theta=Math.random()*Math.PI*2;
points.push({
x:cx+Math.cos(theta)*r,
y:cy+Math.sin(theta)*r,
w:1
});
}

const bbox={x1:cx-spread*2.5,y1:cy-spread*2.5,x2:cx+spread*2.5,y2:cy+spread*2.5};
// Smaller sigma for smaller chambers (tighter features)
const sigma=Math.max(6,10+Math.log(count)*2);
const gridObj=sampleFieldGrid(bbox,points,sigma,STATE.gridStep);

const contours=[];
STATE.thresholds.forEach(iso=>{
const paths=extractContours(gridObj,iso);
if(paths.length)contours.push({iso,paths});
});

speciesLayers.push({species,count,contours,color:COLORS[species]||COLORS.unknown});
});

STATE.mountains.push({chamber:ch,cx,cy,speciesLayers});
});
}

function hashString(str){
let hash=0;
for(let i=0;i<str.length;i++){
hash=((hash<<5)-hash)+str.charCodeAt(i);
hash=hash&hash;
}
return Math.abs(hash);
}

function gaussianRandom(){
let u=0,v=0;
while(u===0)u=Math.random();
while(v===0)v=Math.random();
return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

function fieldValue(x,y,points,sigma){
let v=0;const s2=sigma*sigma;
for(let i=0;i<points.length;i++){
const dx=x-points[i].x,dy=y-points[i].y;
v+=points[i].w*Math.exp(-(dx*dx+dy*dy)/(2*s2));
}
return v;
}

function sampleFieldGrid(bbox,points,sigma,step){
const {x1,y1,x2,y2}=bbox;
const nx=Math.max(2,Math.ceil((x2-x1)/step)+1);
const ny=Math.max(2,Math.ceil((y2-y1)/step)+1);
const grid=new Float32Array(nx*ny);
let vmin=Infinity,vmax=-Infinity;

for(let j=0;j<ny;j++){
for(let i=0;i<nx;i++){
const x=x1+i*step;
const y=y1+j*step;
const v=fieldValue(x,y,points,sigma);
grid[j*nx+i]=v;
if(v<vmin)vmin=v;
if(v>vmax)vmax=v;
}
}

const denom=(vmax-vmin)||1;
for(let k=0;k<grid.length;k++){
grid[k]=(grid[k]-vmin)/denom;
}

return {grid,nx,ny,x1,y1,step};
}

function extractContours(gridObj,iso){
const {grid,nx,ny,x1,y1,step}=gridObj;
const segments=[];

function v(i,j){return grid[j*nx+i];}

for(let j=0;j<ny-1;j++){
for(let i=0;i<nx-1;i++){
const tl=v(i,j)>=iso?1:0;
const tr=v(i+1,j)>=iso?1:0;
const br=v(i+1,j+1)>=iso?1:0;
const bl=v(i,j+1)>=iso?1:0;
const idx=(tl<<3)|(tr<<2)|(br<<1)|bl;

if(idx===0||idx===15)continue;

const xL=x1+i*step,yT=y1+j*step;
const a=v(i,j),b=v(i+1,j),c=v(i+1,j+1),d=v(i,j+1);

const t=(a,b)=>(iso-a)/((b-a)||1e-6);
const tTop=t(a,b),tRight=t(b,c),tBot=t(d,c),tLeft=t(a,d);

const pL=(t01)=>({x:xL,y:yT+t01*step});
const pR=(t01)=>({x:xL+step,y:yT+t01*step});
const pT=(t01)=>({x:xL+t01*step,y:yT});
const pB=(t01)=>({x:xL+t01*step,y:yT+step});

switch(idx){
case 1:case 14:segments.push([pB(tBot),pL(tLeft)]);break;
case 2:case 13:segments.push([pR(tRight),pB(tBot)]);break;
case 3:case 12:segments.push([pR(tRight),pL(tLeft)]);break;
case 4:case 11:segments.push([pT(tTop),pR(tRight)]);break;
case 5:
segments.push([pT(tTop),pL(tLeft)]);
segments.push([pR(tRight),pB(tBot)]);
break;
case 6:case 9:segments.push([pT(tTop),pB(tBot)]);break;
case 7:case 8:segments.push([pT(tTop),pL(tLeft)]);break;
case 10:
segments.push([pT(tTop),pR(tRight)]);
segments.push([pL(tLeft),pB(tBot)]);
break;
}
}
}

return stitchSegments(segments);
}

function stitchSegments(segments){
const paths=[];
const used=new Array(segments.length).fill(false);

for(let i=0;i<segments.length;i++){
if(used[i])continue;
used[i]=true;
const path=segments[i].slice();
let extended=true;

while(extended){
extended=false;
for(let j=i+1;j<segments.length;j++){
if(used[j])continue;
const a=path[path.length-1];
const b=segments[j][0],c=segments[j][1];
const dist2=(p,q)=>(p.x-q.x)**2+(p.y-q.y)**2;

if(dist2(a,b)<1){
path.push(c);
used[j]=true;
extended=true;
continue;
}
if(dist2(a,c)<1){
path.push(b);
used[j]=true;
extended=true;
continue;
}
}
}

if(path.length>2)paths.push(path);
}

return paths;
}

function resize(){
const r=CAN.getBoundingClientRect();
W=Math.floor(r.width*DPR);H=Math.floor(r.height*DPR);
CAN.width=W;CAN.height=H;
CTX.setTransform(1,0,0,1,0,0);
CTX.scale(DPR,DPR);
draw();
}

function clear(){
CTX.setTransform(1,0,0,1,0,0);
CTX.clearRect(0,0,CAN.width/DPR,CAN.height/DPR);
const w=CAN.width/DPR,h=CAN.height/DPR;
const g=CTX.createRadialGradient(w/2,h/2,0,w/2,h/2,Math.max(w,h));
g.addColorStop(0,'rgba(26,58,82,0.03)');
g.addColorStop(1,'rgba(10,14,26,0)');
CTX.fillStyle=g;
CTX.fillRect(0,0,w,h);
}

function draw(){
clear();
CTX.save();
CTX.translate(panX,panY);
CTX.scale(zoom,zoom);

// Rotate terrain to lie horizontal (rotate 90deg around X axis in 2D terms)
// This makes the terrain "lie down" on its back
CTX.transform(1,0,-0.3,0.85,0,0); // Flatten Y, tilt back

STATE.mountains.forEach((mt,idx)=>{
if(STATE.filterDepth!==null&&mt.chamber.depth!==STATE.filterDepth)return;
drawMountain(mt,idx===STATE.highlightIdx);
});

// Highlight ring
if(STATE.highlightIdx>=0){
const mt=STATE.mountains[STATE.highlightIdx];
CTX.save();
CTX.strokeStyle='rgba(77,217,204,0.9)';
CTX.lineWidth=2/zoom;
CTX.setLineDash([8/zoom,8/zoom]);
CTX.beginPath();
CTX.arc(mt.cx,mt.cy,100,0,Math.PI*2);
CTX.stroke();
CTX.restore();
}

CTX.restore();
updateLabels();
}

function drawMountain(mt,highlighted){
let yOffset=0;

// Draw ALL species layers, showing complete composition
mt.speciesLayers.slice().reverse().forEach((layer,li)=>{
const relativeHeight=layer.count/mt.chamber.artifacts.length;

layer.contours.forEach(({iso,paths})=>{
CTX.save();
// Horizontal stacking - offset in Y (which becomes depth after transform)
CTX.translate(0,-yOffset*0.8);

const alpha=0.08+iso*0.12+(highlighted?0.08:0);
const strokeAlpha=0.25+iso*0.15+(highlighted?0.15:0);

CTX.fillStyle=hexToRgba(layer.color,alpha);
CTX.strokeStyle=hexToRgba(layer.color,strokeAlpha);
CTX.lineWidth=Math.max(1,1.5/zoom);

paths.forEach(path=>{
if(path.length<3)return;
CTX.beginPath();
CTX.moveTo(path[0].x,path[0].y);
for(let k=1;k<path.length;k++){
CTX.lineTo(path[k].x,path[k].y);
}
CTX.closePath();
CTX.fill();
CTX.stroke();
});

CTX.restore();
});

yOffset+=35+relativeHeight*100; // More pronounced layers
});
}

function hexToRgba(col,a){
if(col.startsWith('#')){
const h=col.replace('#','');
const n=h.length===3?h.split('').map(x=>x+x).join(''):h;
const r=parseInt(n.slice(0,2),16);
const g=parseInt(n.slice(2,4),16);
const b=parseInt(n.slice(4,6),16);
return `rgba(${r},${g},${b},${a})`;
}
return col;
}

function updateLabels(){
const labelsDiv=document.getElementById('labels');
if(!STATE.showLabels){
labelsDiv.innerHTML='';
return;
}

let html='';
let labelCount=0;
STATE.mountains.forEach((mt,idx)=>{
if(STATE.filterDepth!==null&&mt.chamber.depth!==STATE.filterDepth)return;

const [sx,sy]=worldToScreen(mt.cx,mt.cy-80);
if(sx<-100||sx>CAN.width/DPR+100||sy<-100||sy>CAN.height/DPR+100)return;

// Limit labels to prevent overwhelming (show top chambers by artifact count)
if(labelCount>50&&mt.chamber.artifacts.length<10)return;
labelCount++;

const depth=mt.chamber.depth;
const className=depth===0?'kingdom':'detail';

html+=`<div class="label ${className}" style="left:${sx}px;top:${sy}px">${mt.chamber.name}</div>`;

// Show ALL species composition
let yoff=15;
mt.speciesLayers.slice(0,3).forEach(sp=>{
html+=`<div class="label detail" style="left:${sx}px;top:${sy+yoff}px">${sp.species}: ${sp.count}</div>`;
yoff+=12;
});
if(mt.speciesLayers.length>3){
html+=`<div class="label detail" style="left:${sx}px;top:${sy+yoff}px">+${mt.speciesLayers.length-3} more</div>`;
}
});
labelsDiv.innerHTML=html;
}

function worldToScreen(x,y){
const m=CTX.getTransform();
return[
(x*zoom+panX)*DPR,
(y*zoom+panY)*DPR
];
}

function updateLegend(){
const uniqueSpecies=new Set();
STATE.chambers.forEach(ch=>Object.keys(ch.species).forEach(s=>uniqueSpecies.add(s)));
const speciesArray=Array.from(uniqueSpecies).sort();

const rows=speciesArray.map(s=>{
const color=COLORS[s]||COLORS.unknown;
return `<div class="row"><span class="dot" style="background:${color}"></span><span>${s.toUpperCase()}</span></div>`;
}).join('');

const depthCounts={};
STATE.chambers.forEach(c=>{
const d=c.depth;
depthCounts[d]=(depthCounts[d]||0)+1;
});

const depthStats=Object.entries(depthCounts).sort((a,b)=>parseInt(a[0])-parseInt(b[0]))
.map(([d,cnt])=>`D${d}:${cnt}`).join(' · ');

const stats=`<div style="margin-top:10px;padding-top:8px;border-top:1px solid var(--grid);font-size:10px;color:var(--dim)">
${STATE.chambers.length} chambers · ${STATE.mountains.length} mountains<br>
${depthStats}
</div>`;

document.getElementById('legend').innerHTML=`
<div class="legend-title">Species Strata</div>
${rows}
${stats}
`;
}

function onWheel(e){
e.preventDefault();
const scale=(e.deltaY<0)?1.1:0.9;
const mx=e.clientX,my=e.clientY;
const [wx,wy]=screenToWorld(mx,my);
zoom*=scale;
zoom=Math.min(3,Math.max(0.3,zoom));
const [sx,sy]=worldToScreen2(wx,wy);
panX+=(mx-sx);
panY+=(my-sy);
draw();
}

function screenToWorld(x,y){
return[(x-panX)/zoom,(y-panY)/zoom];
}

function worldToScreen2(x,y){
return[x*zoom+panX,y*zoom+panY];
}

function onDown(e){
dragging=true;
lastX=e.clientX;
lastY=e.clientY;
}

function onMove(e){
if(!dragging)return;
const dx=e.clientX-lastX,dy=e.clientY-lastY;
panX+=dx;
panY+=dy;
lastX=e.clientX;
lastY=e.clientY;
draw();
}

function onUp(){
dragging=false;
}

function onClick(e){
const [wx,wy]=screenToWorld(e.clientX,e.clientY);
let best=-1,bestD=1e9;
STATE.mountains.forEach((mt,i)=>{
const dx=wx-mt.cx,dy=wy-mt.cy;
const d=dx*dx+dy*dy;
if(d<bestD){bestD=d;best=i;}
});
if(best>=0){
STATE.highlightIdx=(STATE.highlightIdx===best?-1:best);
draw();
}
}

// Controls
document.getElementById('btnDepth0').onclick=()=>{
STATE.filterDepth=0;
document.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
document.getElementById('btnDepth0').classList.add('active');
draw();
};

document.getElementById('btnDepth1').onclick=()=>{
STATE.filterDepth=1;
document.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
document.getElementById('btnDepth1').classList.add('active');
draw();
};

document.getElementById('btnDepth2').onclick=()=>{
STATE.filterDepth=2;
document.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
document.getElementById('btnDepth2').classList.add('active');
draw();
};

document.getElementById('btnDepth3').onclick=()=>{
STATE.filterDepth=3;
document.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
document.getElementById('btnDepth3').classList.add('active');
draw();
};

document.getElementById('btnDepth4').onclick=()=>{
STATE.filterDepth=4;
document.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
document.getElementById('btnDepth4').classList.add('active');
draw();
};

document.getElementById('btnAllDepths').onclick=()=>{
STATE.filterDepth=null;
document.querySelectorAll('button').forEach(b=>b.classList.remove('active'));
document.getElementById('btnAllDepths').classList.add('active');
draw();
};

document.getElementById('btnLabels').onclick=function(){
STATE.showLabels=!STATE.showLabels;
this.textContent=`Labels ${STATE.showLabels?'ON':'OFF'}`;
draw();
};

document.getElementById('btnReset').onclick=()=>{
zoom=1;
panX=0;
panY=0;
STATE.highlightIdx=-1;
draw();
};

window.addEventListener('resize',resize);
CAN.addEventListener('wheel',onWheel,{passive:false});
CAN.addEventListener('mousedown',onDown);
window.addEventListener('mousemove',onMove);
window.addEventListener('mouseup',onUp);
CAN.addEventListener('click',onClick);

panX=window.innerWidth/2-960;
panY=window.innerHeight/2-540;

load();
})();
</script>
</body>
</html>
