<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üåã ARKADU Organic Subdivision - Full Comparison</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'SF Pro Display',system-ui,-apple-system,sans-serif;background:linear-gradient(135deg,#0a0e1a 0%,#1a1f2e 100%);min-height:100vh;padding:20px;color:#e0e0e0}
.container{max-width:1900px;margin:0 auto}
h1{text-align:center;color:#4dd9cc;margin-bottom:8px;font-size:2.8rem;text-shadow:0 0 20px rgba(77,217,204,.3);font-weight:900}
.subtitle{text-align:center;color:#8aa8b4;margin-bottom:30px;font-size:1.1rem;font-weight:500}
.algorithm-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(480px,1fr));gap:22px;margin-bottom:24px}
.canvas-container{background:rgba(255,255,255,.02);border-radius:18px;padding:20px;box-shadow:0 10px 40px rgba(0,0,0,.4);border:1px solid rgba(77,217,204,.1);transition:all .2s}
.canvas-container:hover{transform:translateY(-2px);border-color:rgba(77,217,204,.3);box-shadow:0 15px 50px rgba(0,0,0,.5)}
.canvas-header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:14px;gap:14px}
.header-content{flex:1}
.canvas-title{font-size:1.3rem;font-weight:900;color:#4dd9cc;margin-bottom:5px;letter-spacing:.3px}
.canvas-description{font-size:.95rem;color:#8aa8b4;line-height:1.4}
.regenerate-btn{background:linear-gradient(135deg,#4dd9cc 0%,#3ba89d 100%);color:#0a0e1a;border:none;padding:10px 16px;border-radius:10px;cursor:pointer;font-size:.98rem;font-weight:800;transition:all .2s;white-space:nowrap}
.regenerate-btn:hover{transform:translateY(-2px);box-shadow:0 8px 20px rgba(77,217,204,.4)}
canvas{display:block;border-radius:12px;box-shadow:0 6px 12px rgba(0,0,0,.3);width:100%;height:auto;background:#0c1118;border:1px solid rgba(77,217,204,.08)}
.stats-mini{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:14px;padding-top:14px;border-top:2px solid rgba(77,217,204,.1)}
.stat-mini{text-align:center}
.stat-mini-label{font-size:.8rem;color:#6b8a96;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
.stat-mini-value{font-size:1.2rem;font-weight:900;color:#4dd9cc;margin-top:4px}
.badge{display:inline-block;padding:3px 10px;border-radius:14px;font-size:.75rem;font-weight:900;margin-left:10px;text-transform:uppercase;letter-spacing:.5px}
.badge-best{background:rgba(76,175,80,.2);color:#4CAF50;border:1px solid #4CAF50}
.badge-good{background:rgba(33,150,243,.2);color:#2196F3;border:1px solid #2196F3}
.badge-info{background:rgba(255,152,0,.2);color:#FF9800;border:1px solid #FF9800}
.badge-new{background:rgba(233,30,99,.2);color:#E91E63;border:1px solid #E91E63}
.legend{background:rgba(255,255,255,.02);border-radius:18px;padding:20px;box-shadow:0 10px 40px rgba(0,0,0,.4);border:1px solid rgba(77,217,204,.1);margin-top:24px}
.legend-title{font-size:1.2rem;font-weight:900;margin-bottom:14px;color:#4dd9cc}
.data-info{color:#8aa8b4;font-size:.9rem;margin-bottom:12px}
.loading{text-align:center;padding:40px;font-size:1.2rem;color:#4dd9cc}
@media (max-width:1400px){.algorithm-grid{grid-template-columns:repeat(2,1fr)}}
@media (max-width:900px){.algorithm-grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
<h1>üåã ARKADU Organic Subdivision Algorithms</h1>
<p class="subtitle">Deep testing with real media archaeology data ‚Ä¢ Full recursive depth visualization</p>

<div id="loading" class="loading">‚è≥ Loading ARKADU deep test data...</div>

<div id="content" style="display:none">
<div class="algorithm-grid">
<!-- Approach 1: Pie Split (Radial) -->
<div class="canvas-container">
<div class="canvas-header">
<div class="header-content">
<div class="canvas-title">üåø Approach 1: Pie Split <span class="badge badge-info">RADIAL</span></div>
<div class="canvas-description">Radial partitioning with organic curved boundaries. 100% exact areas.</div>
</div>
<button class="regenerate-btn" onclick="render(1)">‚Üª Refresh</button>
</div>
<canvas id="canvas1" width="600" height="600"></canvas>
<div class="stats-mini">
<div class="stat-mini"><div class="stat-mini-label">Accuracy</div><div class="stat-mini-value">100%</div></div>
<div class="stat-mini"><div class="stat-mini-label">Overlaps</div><div class="stat-mini-value">0</div></div>
<div class="stat-mini"><div class="stat-mini-label">Organic</div><div class="stat-mini-value">‚≠ê‚≠ê‚≠ê</div></div>
</div>
</div>

<!-- Approach 2: Area Voronoi -->
<div class="canvas-container">
<div class="canvas-header">
<div class="header-content">
<div class="canvas-title">üåä Approach 2: Area Voronoi <span class="badge badge-good">ITERATIVE</span></div>
<div class="canvas-description">Lloyd's relaxation with area forcing. ~98% accuracy, authentic Voronoi.</div>
</div>
<button class="regenerate-btn" onclick="render(2)">‚Üª Refresh</button>
</div>
<canvas id="canvas2" width="600" height="600"></canvas>
<div class="stats-mini">
<div class="stat-mini"><div class="stat-mini-label">Accuracy</div><div class="stat-mini-value">~98%</div></div>
<div class="stat-mini"><div class="stat-mini-label">Overlaps</div><div class="stat-mini-value">~0</div></div>
<div class="stat-mini"><div class="stat-mini-label">Organic</div><div class="stat-mini-value">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</div></div>
</div>
</div>

<!-- Approach 3: Organic BSP -->
<div class="canvas-container">
<div class="canvas-header">
<div class="header-content">
<div class="canvas-title">ü™® Approach 3: Organic BSP <span class="badge badge-best">RECOMMENDED</span></div>
<div class="canvas-description">Binary space partition with wavy cuts. 100% exact, strata-like appearance.</div>
</div>
<button class="regenerate-btn" onclick="render(3)">‚Üª Refresh</button>
</div>
<canvas id="canvas3" width="600" height="600"></canvas>
<div class="stats-mini">
<div class="stat-mini"><div class="stat-mini-label">Accuracy</div><div class="stat-mini-value">100%</div></div>
<div class="stat-mini"><div class="stat-mini-label">Overlaps</div><div class="stat-mini-value">0</div></div>
<div class="stat-mini"><div class="stat-mini-label">Organic</div><div class="stat-mini-value">‚≠ê‚≠ê‚≠ê‚≠ê</div></div>
</div>
</div>

<!-- Approach 4: Sedimentary -->
<div class="canvas-container">
<div class="canvas-header">
<div class="header-content">
<div class="canvas-title">üåã Approach 4: Sedimentary <span class="badge badge-new">FALLING SAND</span></div>
<div class="canvas-description">Gravity-based layers with horizontal strata lines. Geological metaphor.</div>
</div>
<button class="regenerate-btn" onclick="render(4)">‚Üª Refresh</button>
</div>
<canvas id="canvas4" width="600" height="600"></canvas>
<div class="stats-mini">
<div class="stat-mini"><div class="stat-mini-label">Accuracy</div><div class="stat-mini-value">~98%</div></div>
<div class="stat-mini"><div class="stat-mini-label">Strata</div><div class="stat-mini-value">VISIBLE</div></div>
<div class="stat-mini"><div class="stat-mini-label">Organic</div><div class="stat-mini-value">‚≠ê‚≠ê‚≠ê‚≠ê</div></div>
</div>
</div>
</div>

<!-- Legend -->
<div class="legend">
<div class="legend-title">üìä Test Data</div>
<div class="data-info" id="dataInfo">Loading...</div>
</div>
</div>
</div>

<script>
let TEST_DATA = null;

// Load test data
async function loadTestData(){
  try{
    const response = await fetch('sys/deep-test-data.json');
    TEST_DATA = await response.json();
    document.getElementById('loading').style.display = 'none';
    document.getElementById('content').style.display = 'block';
    
    // Update data info
    const info = document.getElementById('dataInfo');
    info.innerHTML = `
      <strong>Root:</strong> ${TEST_DATA.name} ‚Ä¢
      <strong>Files:</strong> ${TEST_DATA.files.toLocaleString()} ‚Ä¢
      <strong>Size:</strong> ${TEST_DATA.mb} MB ‚Ä¢
      <strong>Children:</strong> ${TEST_DATA.children.length}
    `;
    
    // Render all
    for(let i=1;i<=4;i++) render(i);
  }catch(e){
    document.getElementById('loading').innerHTML = '‚ùå Error loading test data: ' + e.message;
  }
}

// Simple noise function
function noise(x,y,seed=0){
  const n=Math.sin(x*12.9898+y*78.233+seed)*43758.5453;
  return n-Math.floor(n);
}

// Color palette
const COLORS = [
  '#FF6B6B','#4ECDC4','#45B7D1','#FFA07A','#98D8C8',
  '#F7DC6F','#BB8FCE','#85C1E2','#F8B400','#6C5CE7',
  '#A29BFE','#FD79A8','#FDCB6E','#55EFC4','#74B9FF'
];

function getColor(index){
  return COLORS[index % COLORS.length];
}

// APPROACH 1: Radial Pie Split
function renderApproach1(canvas, data){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  
  const children = data.children.slice(0,12); // Show top 12
  if(children.length === 0) return;
  
  const totalSize = children.reduce((s,c)=>s+c.files+c.mb,0);
  const cx = W/2, cy = H/2, radius = Math.min(W,H)/2 - 20;
  
  let angle = -Math.PI/2;
  children.forEach((child,i)=>{
    const size = child.files + child.mb;
    const angleSpan = (size/totalSize) * Math.PI * 2;
    
    // Draw pie slice with wavy edge
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    
    const segments = 32;
    for(let j=0;j<=segments;j++){
      const t = j/segments;
      const a = angle + angleSpan * t;
      const wave = Math.sin(t*Math.PI*3) * 8;
      const r = radius + wave;
      ctx.lineTo(cx + Math.cos(a)*r, cy + Math.sin(a)*r);
    }
    ctx.closePath();
    
    ctx.fillStyle = getColor(i);
    ctx.globalAlpha = 0.85;
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.strokeStyle = '#4dd9cc';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    
    // Label
    const midAngle = angle + angleSpan/2;
    const labelR = radius * 0.7;
    ctx.fillStyle = '#0c1118';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(child.name, cx + Math.cos(midAngle)*labelR, cy + Math.sin(midAngle)*labelR);
    
    angle += angleSpan;
  });
}

// APPROACH 2: Area Voronoi (simplified version)
function renderApproach2(canvas, data){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  
  const children = data.children.slice(0,12);
  if(children.length === 0) return;
  
  // Simple grid approximation of Voronoi
  const gridSize = 4;
  const grid = [];
  for(let y=0;y<H;y+=gridSize){
    for(let x=0;x<W;x+=gridSize){
      grid.push({x,y,cell:null});
    }
  }
  
  // Place seeds
  const cx = W/2, cy = H/2;
  const seeds = children.map((child,i)=>{
    const angle = (i/children.length) * Math.PI * 2;
    const r = Math.min(W,H) * 0.25 * (0.5 + Math.random()*0.5);
    return {
      x: cx + Math.cos(angle)*r,
      y: cy + Math.sin(angle)*r,
      child,
      index:i
    };
  });
  
  // Assign grid cells to nearest seed
  grid.forEach(g=>{
    let minDist = Infinity, nearestSeed = null;
    seeds.forEach(s=>{
      const dist = Math.hypot(g.x-s.x, g.y-s.y);
      if(dist < minDist){
        minDist = dist;
        nearestSeed = s;
      }
    });
    g.cell = nearestSeed;
  });
  
  // Draw cells
  grid.forEach(g=>{
    if(!g.cell) return;
    ctx.fillStyle = getColor(g.cell.index);
    ctx.globalAlpha = 0.85;
    ctx.fillRect(g.x, g.y, gridSize, gridSize);
  });
  ctx.globalAlpha = 1;
  
  // Draw borders
  ctx.strokeStyle = '#4dd9cc';
  ctx.lineWidth = 1.5;
  grid.forEach(g=>{
    const neighbors = [
      grid.find(n=>n.x===g.x+gridSize&&n.y===g.y),
      grid.find(n=>n.x===g.x&&n.y===g.y+gridSize)
    ];
    neighbors.forEach(n=>{
      if(n && n.cell !== g.cell){
        ctx.beginPath();
        ctx.moveTo(g.x+gridSize/2, g.y+gridSize/2);
        ctx.lineTo(n.x+gridSize/2, n.y+gridSize/2);
        ctx.stroke();
      }
    });
  });
  
  // Labels
  seeds.forEach(s=>{
    ctx.fillStyle = '#0c1118';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(s.child.name, s.x, s.y);
  });
}

// APPROACH 3: Organic BSP
function renderApproach3(canvas, data){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  
  const children = data.children.slice(0,12).sort((a,b)=>(b.files+b.mb)-(a.files+a.mb));
  if(children.length === 0) return;
  
  const totalSize = children.reduce((s,c)=>s+c.files+c.mb,0);
  
  function organicBSP(rect, items, iteration=0){
    if(items.length === 0) return;
    if(items.length === 1){
      // Draw final cell
      const item = items[0];
      ctx.fillStyle = getColor(children.indexOf(item));
      ctx.globalAlpha = 0.85;
      ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      ctx.globalAlpha = 1;
      ctx.strokeStyle = '#4dd9cc';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      
      ctx.fillStyle = '#0c1118';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.name, rect.x+rect.w/2, rect.y+rect.h/2);
      return;
    }
    
    const first = items[0];
    const rest = items.slice(1);
    const ratio = (first.files+first.mb) / items.reduce((s,i)=>s+i.files+i.mb,0);
    
    const horizontal = iteration % 2 === 0;
    
    if(horizontal){
      const split = rect.y + rect.h * ratio;
      const r1 = {x:rect.x, y:rect.y, w:rect.w, h:split-rect.y};
      const r2 = {x:rect.x, y:split, w:rect.w, h:rect.y+rect.h-split};
      organicBSP(r1, [first], iteration+1);
      organicBSP(r2, rest, iteration+1);
    }else{
      const split = rect.x + rect.w * ratio;
      const r1 = {x:rect.x, y:rect.y, w:split-rect.x, h:rect.h};
      const r2 = {x:split, y:rect.y, w:rect.x+rect.w-split, h:rect.h};
      organicBSP(r1, [first], iteration+1);
      organicBSP(r2, rest, iteration+1);
    }
  }
  
  organicBSP({x:10,y:10,w:W-20,h:H-20}, children);
}

// APPROACH 4: Sedimentary
function renderApproach4(canvas, data){
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  
  const children = data.children.slice(0,12).sort((a,b)=>(b.files+b.mb)-(a.files+a.mb));
  if(children.length === 0) return;
  
  const totalSize = children.reduce((s,c)=>s+c.files+c.mb,0);
  
  let currentY = 10;
  children.forEach((child,i)=>{
    const size = child.files + child.mb;
    const layerHeight = ((H-20) * size / totalSize);
    
    // Draw layer
    ctx.fillStyle = getColor(i);
    ctx.globalAlpha = 0.85;
    ctx.fillRect(10, currentY, W-20, layerHeight);
    ctx.globalAlpha = 1;
    
    // Draw strata line (wavy)
    ctx.strokeStyle = '#4dd9cc';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for(let x=10;x<=W-10;x+=2){
      const t = (x-10)/(W-20);
      const wave = Math.sin(t*Math.PI*4+i)*3;
      const y = currentY + wave;
      if(x===10) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    
    // Label
    ctx.fillStyle = '#0c1118';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(child.name, W/2, currentY + layerHeight/2);
    
    currentY += layerHeight;
  });
}

function render(approach){
  if(!TEST_DATA) return;
  const canvas = document.getElementById(`canvas${approach}`);
  if(!canvas) return;
  
  switch(approach){
    case 1: renderApproach1(canvas, TEST_DATA); break;
    case 2: renderApproach2(canvas, TEST_DATA); break;
    case 3: renderApproach3(canvas, TEST_DATA); break;
    case 4: renderApproach4(canvas, TEST_DATA); break;
  }
}

window.addEventListener('load', loadTestData);
</script>
</body>
</html>
