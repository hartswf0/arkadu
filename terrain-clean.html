<!DOCTYPE html>
<html><head><meta charset="UTF-8">
<title>ARKADU Terrain — Built from Source</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#000;color:#4dd9cc;font-family:monospace;overflow:hidden}
#container{position:fixed;inset:0}
.hud{position:fixed;top:20px;left:20px;background:rgba(0,0,0,.95);border:1px solid #4dd9cc;
padding:16px;width:320px;z-index:100;font-size:11px;border-radius:8px}
.stat{margin:8px 0;padding:6px;background:rgba(77,217,204,.05);border-radius:4px}
.label{color:#6b8a96;font-size:9px;text-transform:uppercase}
.value{color:#4dd9cc;font-size:12px;font-weight:bold;margin-top:4px}
.inspector{position:fixed;top:20px;right:20px;background:rgba(0,0,0,.95);
border:1px solid #d97b8f;padding:16px;width:380px;z-index:100;border-radius:8px;
max-height:80vh;overflow-y:auto;transform:translateX(450px);transition:transform .3s}
.inspector.open{transform:translateX(0)}
.inspector-title{font-size:13px;color:#d97b8f;font-weight:bold;margin-bottom:12px;
border-bottom:2px solid #d97b8f;padding-bottom:8px}
.close{position:absolute;top:16px;right:16px;cursor:pointer;color:#d97b8f;font-size:18px}
.species-item{padding:8px;margin:6px 0;background:rgba(77,217,204,.05);
border-left:3px solid;border-radius:4px;font-size:11px}
.loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
flex-direction:column;gap:20px;background:#000;z-index:200;font-size:14px;color:#4dd9cc}
.loading.hidden{display:none}
</style>
</head>
<body>
<div id="container"></div>

<div class="loading" id="loading">
<div>⬢ LOADING ARKADU SOURCE DATA ⬢</div>
<div id="status">Fetching primitive.jsonl...</div>
</div>

<div class="hud">
<div class="stat">
<div class="label">Artifacts Loaded</div>
<div class="value" id="totalArtifacts">0</div>
</div>
<div class="stat">
<div class="label">Kingdoms Found</div>
<div class="value" id="kingdoms">0</div>
</div>
<div class="stat">
<div class="label">Species (Extensions)</div>
<div class="value" id="speciesCount">0</div>
</div>
<div class="stat">
<div class="label">Camera Position</div>
<div class="value" id="camPos">0, 0, 0</div>
</div>
<div class="stat">
<div class="label">Terrain Cells</div>
<div class="value" id="cells">0</div>
</div>
</div>

<div class="inspector" id="inspector">
<div class="close" onclick="closeInspector()">×</div>
<div class="inspector-title">AREA ANALYSIS</div>
<div id="inspectorContent"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Simple, clean state from source
const STATE={
artifacts:[],
scene:null,camera:null,renderer:null,terrain:null,
kingdoms:{}, // Grouped by first path segment
speciesCounts:{}, // Global species counts
terrainData:null,
camDist:1000,camAngle:0,camHeight:600,
rotating:false,lastX:0,lastY:0
};

const SPECIES_COLORS={
'png':0x4dd9cc,'jpg':0x4dd9cc,'jpeg':0x4dd9cc,
'mp4':0xd97b8f,'mov':0xd97b8f,'mkv':0xd97b8f,
'mp3':0xe8b849,'wav':0xe8b849,
'py':0xe8b849,'sh':0x6bbd8f,
'json':0x9d7be8,'txt':0x9d7be8,'md':0x9d7be8,
'html':0x6bbd8f,'css':0x6bbd8f,'js':0x6bbd8f,
'pdf':0xffaa44,'zip':0x6b8a96,
'unknown':0x444444
};

async function load(){
try{
updateStatus('Loading artifacts from primitive.jsonl...');
const resp=await fetch('sys/primitive.jsonl');
if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
const text=await resp.text();
STATE.artifacts=text.trim().split('\n').filter(l=>l.trim()).map(l=>JSON.parse(l));
console.log(`✓ Loaded ${STATE.artifacts.length} artifacts`);

updateStatus('Analyzing data structure...');
analyzeData();

updateStatus('Initializing 3D engine...');
await initThree();

updateStatus('Generating terrain from density...');
await generateTerrain();

document.getElementById('loading').classList.add('hidden');
animate();
}catch(e){
console.error('Load error:',e);
document.getElementById('status').innerHTML=`<span style="color:#d97b8f">ERROR: ${e.message}</span>`;
}}

function updateStatus(msg){
document.getElementById('status').textContent=msg;
}

function analyzeData(){
// Group by kingdom (first path segment)
STATE.artifacts.forEach(art=>{
const parts=art.path.split('/');
const kingdom=parts[0]||'ROOT';
if(!STATE.kingdoms[kingdom])STATE.kingdoms[kingdom]=[];
STATE.kingdoms[kingdom].push(art);

// Count species (file extensions)
const ext=(art.ext||'').replace(/^\./,'').toLowerCase()||'unknown';
STATE.speciesCounts[ext]=(STATE.speciesCounts[ext]||0)+1;
});

console.log('Kingdoms:',Object.keys(STATE.kingdoms).length,Object.keys(STATE.kingdoms));
console.log('Species:',Object.keys(STATE.speciesCounts).length,STATE.speciesCounts);

document.getElementById('totalArtifacts').textContent=STATE.artifacts.length.toLocaleString();
document.getElementById('kingdoms').textContent=Object.keys(STATE.kingdoms).length;
document.getElementById('speciesCount').textContent=Object.keys(STATE.speciesCounts).length;
}

async function initThree(){
STATE.scene=new THREE.Scene();
STATE.scene.background=new THREE.Color(0x000000);
STATE.scene.fog=new THREE.Fog(0x000000,800,2500);

STATE.camera=new THREE.PerspectiveCamera(65,window.innerWidth/window.innerHeight,1,3500);
STATE.camera.position.set(0,600,1000);
STATE.camera.lookAt(0,0,0);

STATE.renderer=new THREE.WebGLRenderer({antialias:true});
STATE.renderer.setSize(window.innerWidth,window.innerHeight);
STATE.renderer.setPixelRatio(window.devicePixelRatio);
document.getElementById('container').appendChild(STATE.renderer.domElement);

// Lighting
const ambient=new THREE.AmbientLight(0x1a3a52,0.6);
STATE.scene.add(ambient);

const sun=new THREE.DirectionalLight(0xffffff,0.9);
sun.position.set(600,1000,400);
STATE.scene.add(sun);

const fill=new THREE.DirectionalLight(0x4dd9cc,0.3);
fill.position.set(-400,300,-500);
STATE.scene.add(fill);

// Grid
const grid=new THREE.GridHelper(5000,120,0x4dd9cc,0x1a3a52);
grid.material.opacity=0.12;
grid.material.transparent=true;
grid.position.y=-10;
STATE.scene.add(grid);

// Events
window.addEventListener('resize',onResize);
STATE.renderer.domElement.addEventListener('mousedown',onMouseDown);
STATE.renderer.domElement.addEventListener('mousemove',onMouseMove);
STATE.renderer.domElement.addEventListener('mouseup',onMouseUp);
STATE.renderer.domElement.addEventListener('wheel',onWheel);
STATE.renderer.domElement.addEventListener('click',onClick);

console.log('✓ Three.js initialized');
}

async function generateTerrain(){
const gridSize=150;
const gridExtent=2400;
const gridStep=gridExtent/gridSize;

// Create grids
const densityGrid=Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0));
const speciesGrid=Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0).map(()=>({})));
const artifactGrid=Array(gridSize).fill(0).map(()=>Array(gridSize).fill(0).map(()=>[]));

// Hash function for consistent positioning
function hash(str){
let h=0;
for(let i=0;i<str.length;i++){
h=((h<<5)-h)+str.charCodeAt(i);
h&=h;
}
return Math.abs(h);
}

// Position each kingdom's artifacts
Object.entries(STATE.kingdoms).forEach(([kingdom,artifacts],kidx)=>{
const h=hash(kingdom);
const angle=(h%360)*(Math.PI/180);
const radius=300+(h%400);
const cx=Math.cos(angle)*radius;
const cz=Math.sin(angle)*radius;

console.log(`Kingdom ${kingdom}: ${artifacts.length} artifacts at angle ${(h%360)}° radius ${radius}`);

// Spread artifacts around kingdom center
artifacts.forEach(art=>{
const spread=Math.sqrt(artifacts.length)*1.5;
const r=(Math.random()**0.7)*spread;
const theta=Math.random()*Math.PI*2;
const x=cx+Math.cos(theta)*r;
const z=cz+Math.sin(theta)*r;

const gx=Math.floor((x+gridExtent/2)/gridStep);
const gz=Math.floor((z+gridExtent/2)/gridStep);

if(gx>=0&&gx<gridSize&&gz>=0&&gz<gridSize){
densityGrid[gz][gx]+=1;
const ext=(art.ext||'').replace(/^\./,'').toLowerCase()||'unknown';
speciesGrid[gz][gx][ext]=(speciesGrid[gz][gx][ext]||0)+1;
artifactGrid[gz][gx].push(art);

// Smooth to neighbors
[[0,1],[1,0],[0,-1],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]].forEach(([dx,dz])=>{
const nx=gx+dx,nz=gz+dz;
if(nx>=0&&nx<gridSize&&nz>=0&&nz<gridSize){
densityGrid[nz][nx]+=0.2;
speciesGrid[nz][nx][ext]=(speciesGrid[nz][nx][ext]||0)+0.2;
}
});
}
});
});

// Build terrain mesh
const geometry=new THREE.PlaneGeometry(gridExtent,gridExtent,gridSize-1,gridSize-1);
const vertices=geometry.attributes.position.array;
const colors=[];

let maxDensity=0;
for(let i=0;i<gridSize;i++){
for(let j=0;j<gridSize;j++){
if(densityGrid[i][j]>maxDensity)maxDensity=densityGrid[i][j];
}
}

console.log(`Max density: ${maxDensity}`);

for(let i=0;i<gridSize;i++){
for(let j=0;j<gridSize;j++){
const idx=(i*gridSize+j)*3;
const density=densityGrid[i][j];
const height=Math.sqrt(density)*12; // Height scaling
vertices[idx+2]=height;

// Color by dominant species
const species=speciesGrid[i][j];
const entries=Object.entries(species);
if(entries.length>0){
entries.sort((a,b)=>b[1]-a[1]);
const dominant=entries[0][0];
const colorHex=SPECIES_COLORS[dominant]||SPECIES_COLORS.unknown;
const color=new THREE.Color(colorHex);
const brightness=0.25+Math.min(0.65,density/maxDensity);
colors.push(color.r*brightness,color.g*brightness,color.b*brightness);
}else{
colors.push(0.05,0.08,0.12);
}
}
}

geometry.setAttribute('color',new THREE.Float32BufferAttribute(colors,3));
geometry.computeVertexNormals();

const material=new THREE.MeshStandardMaterial({
vertexColors:true,
wireframe:false,
metalness:0.15,
roughness:0.75,
side:THREE.DoubleSide
});

STATE.terrain=new THREE.Mesh(geometry,material);
STATE.terrain.rotation.x=-Math.PI/2;
STATE.terrain.userData={densityGrid,speciesGrid,artifactGrid,gridSize,gridExtent,gridStep};
STATE.scene.add(STATE.terrain);

STATE.terrainData={densityGrid,speciesGrid,artifactGrid,gridSize,gridExtent,gridStep};
document.getElementById('cells').textContent=`${gridSize}×${gridSize}`;

console.log(`✓ Terrain generated: ${gridSize}×${gridSize} cells`);
}

function animate(){
requestAnimationFrame(animate);

STATE.camera.position.x=Math.cos(STATE.camAngle)*STATE.camDist;
STATE.camera.position.y=STATE.camHeight;
STATE.camera.position.z=Math.sin(STATE.camAngle)*STATE.camDist;
STATE.camera.lookAt(0,0,0);

STATE.renderer.render(STATE.scene,STATE.camera);

const pos=STATE.camera.position;
document.getElementById('camPos').textContent=
`${Math.floor(pos.x)}, ${Math.floor(pos.y)}, ${Math.floor(pos.z)}`;
}

function onClick(e){
const raycaster=new THREE.Raycaster();
const mouse=new THREE.Vector2(
(e.clientX/window.innerWidth)*2-1,
-(e.clientY/window.innerHeight)*2+1
);
raycaster.setFromCamera(mouse,STATE.camera);

const intersects=raycaster.intersectObject(STATE.terrain);
if(intersects.length>0){
const point=intersects[0].point;
inspectArea(point.x,point.z);
}
}

function inspectArea(x,z){
const d=STATE.terrainData;
const gx=Math.floor((x+d.gridExtent/2)/d.gridStep);
const gz=Math.floor((z+d.gridExtent/2)/d.gridStep);

if(gx<0||gx>=d.gridSize||gz<0||gz>=d.gridSize)return;

const density=d.densityGrid[gz][gx];
const species=d.speciesGrid[gz][gx];
const artifacts=d.artifactGrid[gz][gx];

let html=`
<div style="padding:12px;background:rgba(217,123,143,.05);border-radius:6px;margin-bottom:12px">
<div style="font-size:10px;color:#6b8a96;margin-bottom:6px">GRID CELL</div>
<div style="font-size:12px;color:#d97b8f">Position: [${gx}, ${gz}]</div>
<div style="font-size:12px;color:#d97b8f">World: (${Math.floor(x)}, ${Math.floor(z)})</div>
<div style="font-size:12px;color:#d97b8f;margin-top:6px">Density: ${density.toFixed(1)} artifacts</div>
<div style="font-size:12px;color:#d97b8f">Actual artifacts: ${artifacts.length}</div>
</div>`;

if(Object.keys(species).length>0){
html+=`<div style="font-size:11px;color:#d97b8f;font-weight:bold;margin:12px 0">SPECIES COMPOSITION</div>`;
Object.entries(species).sort((a,b)=>b[1]-a[1]).forEach(([sp,cnt])=>{
const colorHex=SPECIES_COLORS[sp]||SPECIES_COLORS.unknown;
const colorStr='#'+colorHex.toString(16).padStart(6,'0');
html+=`<div class="species-item" style="border-color:${colorStr}">
<div style="color:${colorStr};font-weight:bold">${sp.toUpperCase()}</div>
<div style="font-size:9px;color:#6b8a96;margin-top:2px">
${cnt.toFixed(1)} artifacts · ${(cnt/density*100).toFixed(1)}%
</div>
</div>`;
});
}

if(artifacts.length>0){
html+=`<div style="font-size:11px;color:#4dd9cc;font-weight:bold;margin:12px 0">ARTIFACTS (${artifacts.length})</div>`;
artifacts.slice(0,8).forEach(art=>{
const ext=(art.ext||'').replace(/^\./,'')||'?';
html+=`<div style="padding:6px;margin:4px 0;background:rgba(77,217,204,.05);border-radius:3px;font-size:9px">
<div style="color:#4dd9cc;font-weight:bold">${art.name||art.path.split('/').pop()}</div>
<div style="color:#6b8a96;margin-top:2px">${ext} · ${(art.size/1024).toFixed(1)} KB</div>
</div>`;
});
if(artifacts.length>8){
html+=`<div style="font-size:9px;color:#6b8a96;padding:6px">+${artifacts.length-8} more artifacts</div>`;
}
}

document.getElementById('inspectorContent').innerHTML=html;
document.getElementById('inspector').classList.add('open');
}

function closeInspector(){
document.getElementById('inspector').classList.remove('open');
}

function onResize(){
STATE.camera.aspect=window.innerWidth/window.innerHeight;
STATE.camera.updateProjectionMatrix();
STATE.renderer.setSize(window.innerWidth,window.innerHeight);
}

function onMouseDown(e){
STATE.rotating=true;
STATE.lastX=e.clientX;
STATE.lastY=e.clientY;
}

function onMouseMove(e){
if(!STATE.rotating)return;
const dx=e.clientX-STATE.lastX;
const dy=e.clientY-STATE.lastY;
STATE.camAngle-=dx*0.005;
STATE.camHeight=Math.max(100,Math.min(1200,STATE.camHeight-dy));
STATE.lastX=e.clientX;
STATE.lastY=e.clientY;
}

function onMouseUp(){
STATE.rotating=false;
}

function onWheel(e){
e.preventDefault();
STATE.camDist=Math.max(300,Math.min(2000,STATE.camDist+e.deltaY*0.6));
}

load();
</script>
</body></html>
