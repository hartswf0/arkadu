<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<title>üåç MEDIA ECOLOGY - Game of Life</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'SF Mono',Monaco,monospace;background:#000;color:#0f0;padding:20px}
.container{max-width:1900px;margin:0 auto}
h1{color:#0ff;font-size:2.5rem;margin-bottom:10px;text-shadow:0 0 20px #0ff}
.subtitle{color:#0f0;margin-bottom:30px;font-size:1.15rem}
.main-view{display:grid;grid-template-columns:900px 1fr;gap:30px}
canvas{border:3px solid #0f0;background:#000;display:block;box-shadow:0 0 30px rgba(0,255,255,.2)}
.controls{background:#0a0a0a;border:2px solid #0f0;border-radius:10px;padding:20px}
.control-title{color:#0ff;font-size:1.3rem;font-weight:900;margin-bottom:15px}
.btn{background:#0f0;color:#000;border:none;padding:10px 20px;border-radius:5px;cursor:pointer;font-weight:900;font-size:1rem;font-family:inherit;width:100%;margin:5px 0}
.btn:hover{background:#0ff;box-shadow:0 0 15px #0ff}
.btn-secondary{background:#333;color:#0f0;border:1px solid #0f0}
.media-rules{background:#1a1a1a;padding:15px;border:1px solid #333;border-radius:5px;margin:10px 0}
.media-type{background:#0a0a0a;padding:10px;margin:5px 0;border-left:4px solid;border-radius:3px}
.media-name{color:#0ff;font-weight:900;margin-bottom:5px}
.media-behavior{color:#888;font-size:.85rem;line-height:1.5}
.stats{background:#1a1a1a;padding:15px;border:1px solid #333;border-radius:5px;margin-top:15px;font-size:.85rem}
.stat-row{display:flex;justify-content:space-between;padding:6px 0;border-bottom:1px solid #222}
.stat-row:last-child{border-bottom:none}
.stat-label{color:#888}
.stat-value{color:#0ff;font-weight:bold}
.progress-bar{background:#333;height:16px;border-radius:8px;overflow:hidden;margin-top:5px}
.progress-fill{height:100%;transition:width .3s;display:flex;align-items:center;justify-content:center;color:#000;font-weight:900;font-size:.75rem}
</style>
</head>
<body>
<div class="container">
<h1>üåç MEDIA ECOLOGY - Game of Life</h1>
<p class="subtitle">Real ARKADU data ‚Ä¢ File types as life forms ‚Ä¢ Physics-based evolution ‚Ä¢ Volume density dynamics</p>

<div class="main-view">
<div>
<canvas id="canvas" width="900" height="900"></canvas>
</div>

<div class="controls">
<div class="control-title">üéÆ Evolution Control</div>
<button class="btn" onclick="start()">‚ñ∂ Start Evolution</button>
<button class="btn btn-secondary" onclick="step()">‚û° Single Step</button>
<button class="btn btn-secondary" onclick="reset()">‚Üª Reset</button>
<button class="btn btn-secondary" onclick="togglePause()">‚è∏ Pause</button>

<div class="control-title" style="margin-top:20px">üß¨ Media Type Rules</div>
<div class="media-rules" id="mediaRules"></div>

<div class="stats" id="stats"></div>
</div>
</div>
</div>

<div style="background:#1a1a1a;padding:20px;border:2px solid #0ff;border-radius:10px;margin-top:20px">
<h2 style="color:#0ff;margin-bottom:15px">üåç THE MEDIA ECOLOGY</h2>
<p style="color:#0f0;line-height:1.8">
<strong>MP4 (Video):</strong> Heavy, sinks, spreads slowly ‚Ä¢ High mass, low diffusion<br>
<strong>PNG (Image):</strong> Medium weight, clusters ‚Ä¢ Balanced mass/volume<br>
<strong>WAV (Audio):</strong> Flows like water ‚Ä¢ Wave propagation, medium density<br>
<strong>TXT (Text):</strong> Light, floats, spreads fast ‚Ä¢ Low mass, high diffusion<br>
<strong>JSON (Metadata):</strong> Connects networks ‚Ä¢ Link behavior, adaptive<br>
<strong>PY (Code):</strong> Mutates neighbors ‚Ä¢ Transformative, spreads through contact<br>
Each media type evolves according to its physical properties until target percentages met!
</p>
</div>

<script>
// REAL ARKADU DATA (from memories)
const MEDIA_TYPES={
  mp4:{name:'MP4',color:'#FF6B6B',totalGB:41.1,count:734,pct:72.7,
       mass:9,diffusion:1,gravity:3,cluster:2},
  png:{name:'PNG',color:'#4ECDC4',totalGB:6.4,count:6537,pct:11.3,
       mass:5,diffusion:4,gravity:1,cluster:7},
  wav:{name:'WAV',color:'#45B7D1',totalGB:4.1,count:426,pct:7.2,
       mass:6,diffusion:5,gravity:2,cluster:3},
  jpg:{name:'JPG',color:'#FFA07A',totalGB:1.2,count:1200,pct:2.1,
       mass:4,diffusion:5,gravity:1,cluster:6},
  json:{name:'JSON',color:'#98D8C8',totalGB:0.8,count:576,pct:1.4,
       mass:1,diffusion:8,gravity:0,cluster:1},
  py:{name:'PY',color:'#F7DC6F',totalGB:0.5,count:253,pct:0.9,
       mass:2,diffusion:6,gravity:0,cluster:2},
  txt:{name:'TXT',color:'#BB8FCE',totalGB:0.3,count:400,pct:0.5,
       mass:1,diffusion:9,gravity:-1,cluster:1},
  other:{name:'OTHER',color:'#85C1E2',totalGB:2.6,count:968,pct:4.6,
       mass:3,diffusion:4,gravity:1,cluster:3}
};

const GRID_SIZE=150;
const CELL_SIZE=900/GRID_SIZE;
let grid,nextGrid,state,mediaTypes;

function reset(){
  grid=new Uint8Array(GRID_SIZE*GRID_SIZE).fill(255);
  nextGrid=new Uint8Array(GRID_SIZE*GRID_SIZE).fill(255);
  
  // Convert to array for easier processing
  mediaTypes=Object.entries(MEDIA_TYPES).map(([key,data],i)=>({
    id:i,
    key,
    ...data,
    target:data.pct/100,
    current:0
  }));
  
  // Seed media types randomly based on volume
  const totalCells=GRID_SIZE*GRID_SIZE;
  mediaTypes.forEach(m=>{
    const seedCount=Math.floor(totalCells*m.target*0.5); // Start at 50% of target
    for(let i=0;i<seedCount;i++){
      const x=Math.floor(Math.random()*GRID_SIZE);
      const y=Math.floor(Math.random()*GRID_SIZE);
      grid[y*GRID_SIZE+x]=m.id;
    }
  });
  
  state={iter:0,running:false,paused:false};
  updateMediaRules();
  updateStats();
  draw();
}

function step(){
  // Copy grid
  for(let i=0;i<grid.length;i++)nextGrid[i]=grid[i];
  
  // Count current coverage
  mediaTypes.forEach(m=>m.current=0);
  for(let i=0;i<grid.length;i++){
    if(grid[i]<255)mediaTypes[grid[i]].current++;
  }
  
  // Apply media-specific CA rules
  for(let y=1;y<GRID_SIZE-1;y++){
    for(let x=1;x<GRID_SIZE-1;x++){
      const idx=y*GRID_SIZE+x;
      const cellType=grid[idx];
      
      if(cellType<255){
        // FILLED CELL - Apply media type rules
        const media=mediaTypes[cellType];
        applyMediaRules(x,y,idx,media);
      }else{
        // EMPTY CELL - Competition for space
        applyCompetitionRules(x,y,idx);
      }
    }
  }
  
  // Swap buffers
  [grid,nextGrid]=[nextGrid,grid];
  
  state.iter++;
  updateStats();
  draw();
  
  // Check if targets reached
  const balanced=mediaTypes.filter(m=>{
    const pct=m.current/(GRID_SIZE*GRID_SIZE);
    return Math.abs(pct-m.target)<0.01;
  }).length;
  
  return balanced===mediaTypes.length;
}

function applyMediaRules(x,y,idx,media){
  const neighbors=getNeighbors(x,y);
  const sameType=neighbors.filter(n=>n===media.id).length;
  
  // GRAVITY: Heavy media sinks
  if(media.gravity>0 && y<GRID_SIZE-1){
    const below=grid[(y+1)*GRID_SIZE+x];
    if(below===255 || (below<255 && mediaTypes[below].gravity<media.gravity)){
      // Swap down (sink)
      if(Math.random()<media.gravity/10){
        nextGrid[idx]=below;
        nextGrid[(y+1)*GRID_SIZE+x]=media.id;
        return;
      }
    }
  }
  
  // FLOAT: Light media rises
  if(media.gravity<0 && y>0){
    const above=grid[(y-1)*GRID_SIZE+x];
    if(above===255 || (above<255 && mediaTypes[above].gravity>media.gravity)){
      // Swap up (float)
      if(Math.random()<0.2){
        nextGrid[idx]=above;
        nextGrid[(y-1)*GRID_SIZE+x]=media.id;
        return;
      }
    }
  }
  
  // CLUSTERING: Some types cluster more
  if(sameType<media.cluster){
    // Not enough neighbors - might die if sparse
    const deficit=media.current/(GRID_SIZE*GRID_SIZE)-media.target;
    if(deficit>0.01 && Math.random()<0.1){
      nextGrid[idx]=255; // Die (overcrowded)
    }
  }
  
  // DIFFUSION: Spread to neighbors
  if(media.diffusion>5 && sameType<8){
    const emptyNeighbors=neighbors.filter(n=>n===255).length;
    if(emptyNeighbors>0 && Math.random()<media.diffusion/20){
      // Spread to random empty neighbor
      const dir=Math.floor(Math.random()*4);
      const nx=x+(dir===0?-1:dir===1?1:0);
      const ny=y+(dir===2?-1:dir===3?1:0);
      if(nx>=0&&nx<GRID_SIZE&&ny>=0&&ny<GRID_SIZE){
        if(nextGrid[ny*GRID_SIZE+nx]===255){
          nextGrid[ny*GRID_SIZE+nx]=media.id;
        }
      }
    }
  }
}

function applyCompetitionRules(x,y,idx){
  const neighbors=getNeighbors(x,y);
  
  // Count neighbors by type
  const counts={};
  neighbors.forEach(n=>{
    if(n<255)counts[n]=(counts[n]||0)+1;
  });
  
  if(Object.keys(counts).length===0)return;
  
  // Weight by: neighbor_count √ó growth_pressure
  const weights={};
  for(const [typeId,count] of Object.entries(counts)){
    const media=mediaTypes[typeId];
    const currentPct=media.current/(GRID_SIZE*GRID_SIZE);
    const deficit=media.target-currentPct;
    
    // Growth pressure: positive deficit = wants to grow
    const pressure=Math.max(0,deficit*10);
    weights[typeId]=count*pressure*media.diffusion;
  }
  
  // Weighted random selection
  const total=Object.values(weights).reduce((a,b)=>a+b,0);
  if(total===0)return;
  
  let r=Math.random()*total;
  for(const [typeId,weight] of Object.entries(weights)){
    r-=weight;
    if(r<=0){
      nextGrid[idx]=parseInt(typeId);
      break;
    }
  }
}

function getNeighbors(x,y){
  return[
    grid[(y-1)*GRID_SIZE+x-1],grid[(y-1)*GRID_SIZE+x],grid[(y-1)*GRID_SIZE+x+1],
    grid[y*GRID_SIZE+x-1],                            grid[y*GRID_SIZE+x+1],
    grid[(y+1)*GRID_SIZE+x-1],grid[(y+1)*GRID_SIZE+x],grid[(y+1)*GRID_SIZE+x+1]
  ];
}

function start(){
  if(state.running)return;
  state.running=true;
  state.paused=false;
  
  const interval=setInterval(()=>{
    if(state.paused)return;
    
    const done=step();
    if(done || state.iter>1000){
      clearInterval(interval);
      state.running=false;
    }
  },50);
}

function togglePause(){
  state.paused=!state.paused;
}

function draw(){
  const canvas=document.getElementById('canvas');
  const ctx=canvas.getContext('2d');
  const img=ctx.createImageData(900,900);
  
  for(let y=0;y<GRID_SIZE;y++){
    for(let x=0;x<GRID_SIZE;x++){
      const cellType=grid[y*GRID_SIZE+x];
      if(cellType<255){
        const media=mediaTypes[cellType];
        const c=media.color;
        const r=parseInt(c.slice(1,3),16);
        const g=parseInt(c.slice(3,5),16);
        const b=parseInt(c.slice(5,7),16);
        
        // Fill cell
        for(let dy=0;dy<CELL_SIZE;dy++){
          for(let dx=0;dx<CELL_SIZE;dx++){
            const px=x*CELL_SIZE+dx;
            const py=y*CELL_SIZE+dy;
            const pidx=(py*900+px)*4;
            img.data[pidx]=r;
            img.data[pidx+1]=g;
            img.data[pidx+2]=b;
            img.data[pidx+3]=255;
          }
        }
      }
    }
  }
  
  ctx.putImageData(img,0,0);
}

function updateMediaRules(){
  const html=mediaTypes.map(m=>{
    const behaviors=[];
    if(m.gravity>2)behaviors.push('ü™® Sinks (heavy)');
    else if(m.gravity<0)behaviors.push('‚òÅÔ∏è Floats (light)');
    if(m.diffusion>7)behaviors.push('üí® Spreads fast');
    else if(m.diffusion<3)behaviors.push('üêå Spreads slow');
    if(m.cluster>5)behaviors.push('üîó Clusters strongly');
    
    return`
      <div class="media-type" style="border-color:${m.color}">
        <div class="media-name">${m.name} (${m.pct}% target)</div>
        <div class="media-behavior">
          ${behaviors.join(' ‚Ä¢ ')}<br>
          Mass:${m.mass} Diffusion:${m.diffusion} Gravity:${m.gravity>0?'+':''}${m.gravity}
        </div>
      </div>
    `;
  }).join('');
  
  document.getElementById('mediaRules').innerHTML=html;
}

function updateStats(){
  mediaTypes.forEach(m=>m.current=0);
  for(let i=0;i<grid.length;i++){
    if(grid[i]<255)mediaTypes[grid[i]].current++;
  }
  
  const totalFilled=mediaTypes.reduce((s,m)=>s+m.current,0);
  const coverage=(totalFilled/(GRID_SIZE*GRID_SIZE)*100).toFixed(1);
  
  const statsHtml=`
    <div class="stat-row"><span class="stat-label">Generation:</span><span class="stat-value">${state.iter}</span></div>
    <div class="stat-row"><span class="stat-label">Coverage:</span><span class="stat-value">${coverage}%</span></div>
  `+mediaTypes.map(m=>{
    const current=(m.current/(GRID_SIZE*GRID_SIZE)*100).toFixed(2);
    const target=(m.target*100).toFixed(2);
    const diff=parseFloat(current)-parseFloat(target);
    const status=Math.abs(diff)<1?'‚úì':diff>0?'‚Üë':'‚Üì';
    
    return`
      <div class="stat-row" style="flex-direction:column;align-items:stretch">
        <div style="display:flex;justify-content:space-between">
          <span class="stat-label">${status} ${m.name}:</span>
          <span class="stat-value">${current}% / ${target}%</span>
        </div>
        <div class="progress-bar">
          <div class="progress-fill" style="width:${Math.min(100,(current/target)*100)}%;background:${m.color}">
            ${diff>0?'+':''}${diff.toFixed(2)}%
          </div>
        </div>
      </div>
    `;
  }).join('');
  
  document.getElementById('stats').innerHTML=statsHtml;
}

window.addEventListener('load',reset);
</script>
</body>
</html>
