<!DOCTYPE html>
<html><head><meta charset="UTF-8">
<title>DOUBLE BARREL: Voronoi + Sediment Split View</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0e1a;color:#4dd9cc;font-family:monospace;overflow:hidden;height:100vh;margin:0}
#sidebar{display:none}
#main{position:fixed;inset:0;display:flex}
#voronoiView{flex:1;position:relative;border-right:2px solid rgba(77,217,204,0.3)}
#sedimentView{flex:1;position:relative}
canvas{display:block;cursor:pointer}
.tree-item{padding:6px 8px;margin:2px 0;cursor:pointer;border-radius:3px;font-size:10px;
transition:all .2s}
.tree-item:hover{background:rgba(77,217,204,.15)}
.tree-item.active{background:rgba(77,217,204,.25);font-weight:bold}
.tree-item.has-children::before{content:'‚ñ∏ ';color:#4dd9cc}
.tree-item.expanded::before{content:'‚ñæ '}
.depth-0{color:#4dd9cc}
.depth-1{color:#6be8df}
.depth-2{color:#6bbd8f}
.depth-3{color:#e8b849}
.depth-4{color:#d97b8f}
.depth-5{color:#9d7be8}
.depth-6{color:#4dd9cc;opacity:0.8}
.depth-7{color:#6be8df;opacity:0.8}
.depth-8{color:#6bbd8f;opacity:0.8}
.depth-9{color:#e8b849;opacity:0.8}
.depth-10{color:#d97b8f;opacity:0.8}
.depth-11{color:#9d7be8;opacity:0.8}
.stats{background:rgba(77,217,204,.1);padding:12px;margin:10px 0;border-radius:5px;font-size:11px}
.stat-line{margin:4px 0}
.controls{margin:15px 0;display:flex;gap:8px;flex-wrap:wrap}
button{padding:8px 12px;background:rgba(77,217,204,.1);border:1px solid #4dd9cc;
color:#4dd9cc;cursor:pointer;border-radius:4px;font-size:10px;font-family:monospace}
button:hover{background:rgba(77,217,204,.25)}
.info-panel{position:fixed;bottom:20px;left:340px;background:rgba(0,0,0,.95);
border:1px solid #4dd9cc;padding:15px;border-radius:5px;max-width:450px;max-height:300px;
overflow-y:auto;font-size:11px;line-height:1.6}
.territory-panel{position:fixed;top:80px;right:20px;width:140px;background:rgba(0,0,0,.95);
border:1px solid rgba(77,217,204,.3);padding:12px;border-radius:8px;max-height:calc(100vh - 120px);overflow-y:auto;backdrop-filter:blur(15px);box-shadow:0 0 20px rgba(77,217,204,.2)}
.territory-header{color:#e8b849;font-size:15px;font-weight:bold;margin-bottom:15px;
border-bottom:1px solid rgba(232,184,73,0.3);padding-bottom:10px}
.data-section{margin:12px 0;padding:12px;background:rgba(232,184,73,0.05);
border-left:3px solid #e8b849;border-radius:4px}
.data-label{color:#6b8a96;font-size:9px;text-transform:uppercase;margin-bottom:4px}
.data-value{color:#e8b849;font-size:12px;font-weight:bold}
.species-item{display:flex;justify-content:space-between;padding:6px 8px;margin:4px 0;
background:rgba(77,217,204,0.05);border-radius:3px;font-size:10px}
.species-name{color:#4dd9cc}
.species-count{color:#6b8a96}
.geometry-viz{margin:10px 0;padding:10px;background:rgba(0,0,0,0.5);border-radius:5px;
border:1px solid rgba(232,184,73,0.2)}
h3{color:#4dd9cc;margin-bottom:10px}
select{padding:8px 12px;background:rgba(77,217,204,.1);border:1px solid #4dd9cc;
color:#4dd9cc;cursor:pointer;border-radius:4px;font-size:10px;font-family:monospace}
select:hover{background:rgba(77,217,204,.25)}
option{background:#0a0e1a;color:#4dd9cc}
.filter-section{margin:15px 0;padding:12px;background:rgba(77,217,204,.05);border-radius:5px;
border:1px solid rgba(77,217,204,0.2)}
.filter-label{color:#6b8a96;font-size:9px;text-transform:uppercase;margin-bottom:6px}

/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   4B CONTROL SURFACES - Standardized Interface
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

/* Vertical control strip */
#excavationTools{position:fixed;left:20px;top:50%;transform:translateY(-50%);background:rgba(0,0,0,.95);border:1px solid rgba(77,217,204,.3);padding:15px 8px;border-radius:8px;z-index:100;backdrop-filter:blur(10px);width:60px;box-shadow:0 0 15px rgba(77,217,204,.3)}
.tool-section{margin-bottom:15px;padding-bottom:15px;border-bottom:1px solid rgba(77,217,204,.2)}
.tool-section:last-child{border-bottom:none;margin-bottom:0}
.tool-label{font-size:7px;color:#6b8a96;margin-bottom:8px;text-transform:uppercase;letter-spacing:1px;text-align:center}
.tool-row{display:flex;flex-direction:column;gap:8px;align-items:center}
.tool-btn{width:44px;height:44px;background:rgba(77,217,204,.1);border:1px solid #4dd9cc;border-radius:6px;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s;position:relative;font-size:10px}
.tool-btn:hover{background:rgba(77,217,204,.3);transform:scale(1.05)}
.tool-btn:active{transform:scale(0.95)}
.tool-btn.active{background:rgba(232,184,73,.25);border-color:#e8b849;box-shadow:0 0 12px rgba(232,184,73,.6);animation:pulse 2s ease-in-out infinite}

@keyframes pulse{
  0%, 100%{box-shadow:0 0 12px rgba(232,184,73,.6)}
  50%{box-shadow:0 0 20px rgba(232,184,73,.9)}
}

/* Geometric shapes */
.shape{width:24px;height:24px;position:relative}
.shape-triangle{width:0;height:0;border-left:12px solid transparent;border-right:12px solid transparent;border-bottom:20px solid currentColor}
.shape-triangle.up{transform:rotate(0deg)}
.shape-triangle.down{transform:rotate(180deg)}
.shape-triangle.left{transform:rotate(90deg)}
.shape-triangle.right{transform:rotate(-90deg)}
.shape-circle{width:20px;height:20px;border-radius:50%;border:3px solid currentColor}
.shape-square{width:18px;height:18px;border:3px solid currentColor}
.shape-home{width:20px;height:16px;position:relative}
.shape-home::before{content:'';position:absolute;width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-bottom:10px solid currentColor;top:-8px;left:0}
.shape-home::after{content:'';position:absolute;width:20px;height:10px;background:currentColor;bottom:0;left:0}

/* HUD - Operating System style */
#hud{position:fixed;top:20px;left:100px;right:180px;background:rgba(0,0,0,.92);border:1px solid rgba(77,217,204,.4);padding:12px 20px;border-radius:8px;z-index:10;backdrop-filter:blur(15px);box-shadow:0 0 20px rgba(77,217,204,.2);display:flex;justify-content:space-between;align-items:center;gap:20px;flex-wrap:wrap}
.hud-section{display:flex;flex-direction:column;gap:3px;min-width:50px}
.hud-label{font-size:8px;color:#6b8a96;text-transform:uppercase;letter-spacing:1px}
.hud-value{font-size:11px;color:#4dd9cc;font-weight:bold}
.hud-mode{font-size:13px;color:#e8b849;font-weight:bold;padding:6px 12px;background:rgba(232,184,73,.15);border-radius:5px;border:1px solid rgba(232,184,73,.4);text-transform:uppercase;letter-spacing:1px;white-space:nowrap}
.hud-filters{display:flex;gap:8px;align-items:center}
.filter-chip{font-size:9px;padding:4px 10px;background:rgba(77,217,204,.15);border:1px solid rgba(77,217,204,.4);border-radius:12px;cursor:pointer;transition:all .2s;color:#4dd9cc}
.filter-chip:hover{background:rgba(77,217,204,.3);transform:translateY(-1px)}

/* Core sample styling */
.core-header{font-size:9px;color:#6b8a96;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;text-align:center;border-bottom:1px solid rgba(77,217,204,.2);padding-bottom:6px}
.core-segment{padding:8px;margin:4px 0;background:rgba(77,217,204,.05);border-left:3px solid #9d7be8;border-radius:3px;cursor:pointer;transition:all .2s;font-size:9px}
.core-segment:hover{background:rgba(77,217,204,.15);transform:translateX(3px)}
.core-segment.current{background:rgba(232,184,73,.2);border-left-color:#e8b849;font-weight:bold}
.core-depth{color:#6b8a96;font-size:8px}
.core-name{color:#4dd9cc;font-size:10px;margin-top:2px}

.tool-btn::after{content:attr(data-label);position:absolute;left:55px;top:50%;transform:translateY(-50%);background:rgba(0,0,0,.95);border:1px solid #4dd9cc;padding:6px 10px;border-radius:4px;font-size:10px;white-space:nowrap;opacity:0;pointer-events:none;transition:opacity .2s;z-index:1}
.tool-btn:hover::after{opacity:1}
</style>
</head>
<body>

<!-- 4B CONTROL SURFACES OVERLAY -->
<div id="excavationTools">
  <div class="tool-section">
    <div class="tool-label">NAV</div>
    <div class="tool-row">
      <div class="tool-btn" onclick="navParent()" data-label="Ascend (Esc)" style="color:#4dd9cc">
        <div class="shape"><div class="shape-triangle up" style="color:#4dd9cc"></div></div>
      </div>
      <div class="tool-btn" onclick="navChild()" data-label="Descend (‚Üì)" style="color:#6bbd8f">
        <div class="shape"><div class="shape-triangle down" style="color:#6bbd8f"></div></div>
      </div>
      <div class="tool-btn" onclick="navPrevSibling()" data-label="Prev Sibling (‚Üê)" style="color:#9d7be8">
        <div class="shape"><div class="shape-triangle left" style="color:#9d7be8"></div></div>
      </div>
      <div class="tool-btn" onclick="navNextSibling()" data-label="Next Sibling (‚Üí)" style="color:#9d7be8">
        <div class="shape"><div class="shape-triangle right" style="color:#9d7be8"></div></div>
      </div>
      <div class="tool-btn" onclick="viewRoot()" data-label="Jump to Root (H)" style="color:#e8b849">
        <div class="shape shape-home" style="color:#e8b849"></div>
      </div>
    </div>
  </div>
  
  <div class="tool-section">
    <div class="tool-label">MODE</div>
    <div class="tool-row">
      <div class="tool-btn active" id="modeExplore" onclick="setMode('explore')" data-label="Explore (E)" style="color:#4dd9cc">E</div>
      <div class="tool-btn" id="modeFlag" onclick="setMode('flag')" data-label="Flag (F)" style="color:#e8b849">F</div>
      <div class="tool-btn" id="modeTag" onclick="setMode('tag')" data-label="Tag (T)" style="color:#9d7be8">T</div>
      <div class="tool-btn" id="modeMeasure" onclick="setMode('measure')" data-label="Measure (M)" style="color:#6bbd8f">M</div>
    </div>
  </div>
  
  <div class="tool-section">
    <div class="tool-label">VIEW</div>
    <div class="tool-row">
      <div class="tool-btn active" id="toggleVoronoi" onclick="toggleLayer('voronoi')" data-label="Voronoi Layer" style="color:#4dd9cc">V</div>
      <div class="tool-btn" id="toggleSediment" onclick="toggleLayer('sediment')" data-label="Sediment Layer" style="color:#e8b849">S</div>
    </div>
  </div>
  
  <div class="tool-section">
    <div class="tool-label">DATA</div>
    <div class="tool-row">
      <div class="tool-btn" onclick="loadRealData()" data-label="Load ARKADU" style="color:#6bbd8f">
        <div class="shape shape-circle" style="color:#6bbd8f"></div>
      </div>
      <div class="tool-btn" onclick="generateStructure(9)" data-label="Generate Mock" style="color:#6b8a96">
        <div class="shape shape-square" style="color:#6b8a96"></div>
      </div>
    </div>
  </div>
</div>

<!-- Mode overlay -->
<div id="modeOverlay" class="mode-overlay"></div>

<!-- HUD - Operating System Interface -->
<div id="hud">
  <div class="hud-mode" id="hudMode">‚õè EXPLORE</div>
  <div class="hud-section">
    <div class="hud-label">Depth</div>
    <div class="hud-value" id="hudDepth">D0</div>
  </div>
  <div class="hud-section">
    <div class="hud-label">Nodes</div>
    <div class="hud-value" id="totalNodes">0</div>
  </div>
  <div class="hud-section">
    <div class="hud-label">Current</div>
    <div class="hud-value" id="currentView">ROOT</div>
  </div>
  <div class="hud-section">
    <div class="hud-label">Children</div>
    <div class="hud-value" id="childCount">0</div>
  </div>
  <div class="hud-section">
    <div class="hud-label">Flagged</div>
    <div class="hud-value" id="hudFlags" style="color:#e8b849">0</div>
  </div>
  <div class="hud-section">
    <div class="hud-label">Tagged</div>
    <div class="hud-value" id="hudTags" style="color:#9d7be8">0</div>
  </div>
  <div class="hud-section">
    <div class="hud-label">Layers</div>
    <div class="hud-value" id="hudLayers" style="color:#6bbd8f;font-size:9px">V</div>
  </div>
  <div class="hud-filters">
    <div class="filter-chip" onclick="toggleFileTree()">üìÅ</div>
    <div class="filter-chip">‚öô</div>
  </div>
</div>

<!-- Collapsible File Tree Panel - Slides from right side -->
<div id="fileTreePanel" style="display:none;position:fixed;top:80px;right:180px;width:300px;max-height:calc(100vh - 120px);background:rgba(0,0,0,0.95);border:1px solid rgba(77,217,204,0.4);border-radius:8px;padding:15px;overflow-y:auto;z-index:200;backdrop-filter:blur(15px);box-shadow:0 0 30px rgba(0,0,0,0.8)">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;border-bottom:1px solid rgba(77,217,204,0.3);padding-bottom:8px">
    <div style="font-size:12px;color:#4dd9cc;font-weight:bold">üìÅ FILE TREE</div>
    <div onclick="toggleFileTree()" style="cursor:pointer;color:#6b8a96;font-size:18px">√ó</div>
  </div>
  <div id="fileTreeContent" style="font-size:10px;line-height:1.6"></div>
</div>

<div id="sidebar" style="display:none">
<h3>üåä APPROACH 2: Iterative Area Forcing</h3>
<div class="stats">
<div class="stat-line"><strong>Max Depth:</strong> <span id="maxDepth">0</span></div>
<div class="stat-line"><strong>Total Nodes:</strong> <span id="totalNodes">0</span></div>
<div class="stat-line"><strong>Current View:</strong> <span id="currentView">ROOT</span></div>
<div class="stat-line"><strong>Depth:</strong> <span id="currentDepth">0</span></div>
<div class="stat-line"><strong>Children:</strong> <span id="childCount">0</span></div>
</div>

<div class="controls">
<button onclick="loadRealData()" style="background:rgba(232,184,73,.2);border-color:#e8b849">üóÇÔ∏è LOAD ARKADU</button>
<button onclick="generateStructure(6)">6 Mock</button>
<button onclick="generateStructure(9)">9 Mock</button>
<button onclick="viewRoot()">‚Üë ROOT</button>
</div>

<div class="filter-section">
<div class="filter-label">üé® Filter by Species</div>
<select id="speciesFilter" onchange="applySpeciesFilter()">
<option value="all">All Media Types</option>
</select>
<div style="margin-top:8px;font-size:9px;color:#6b8a96" id="filterStatus">Showing all territories</div>
</div>

<div style="margin:15px 0;padding:12px;background:rgba(232,184,73,.1);border-radius:5px;border:1px solid rgba(232,184,73,0.3)">
<div style="color:#e8b849;font-size:10px;font-weight:bold;margin-bottom:8px">‚öñÔ∏è SCALE FORMULA</div>
<div style="font-size:9px;color:#6b8a96;line-height:1.8">
<div><strong style="color:#4dd9cc">Territory Size =</strong></div>
<div style="margin-left:10px;color:#e8b849">Volume + (Mass / 1MB)</div>
<div style="margin-top:6px;border-top:1px solid rgba(232,184,73,0.2);padding-top:6px">
<div><strong style="color:#4dd9cc">Volume:</strong> File count</div>
<div><strong style="color:#4dd9cc">Mass:</strong> Total bytes</div>
</div>
<div style="margin-top:8px;font-size:8px;font-style:italic;color:#6b8a96">
Balances quantity + size for fair representation
</div>
</div>
</div>

<div style="margin:15px 0;padding:10px;background:rgba(77,217,204,.05);border-radius:5px;border:1px solid rgba(77,217,204,0.2)">
<div style="color:#6b8a96;font-size:9px;text-transform:uppercase;margin-bottom:6px">‚å®Ô∏è Navigation Shortcuts</div>
<div style="font-size:9px;line-height:1.6;color:#4dd9cc">
<div><kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">‚Üë</kbd> / <kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">Esc</kbd> Parent</div>
<div><kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">‚Üì</kbd> First Child</div>
<div><kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">‚Üê</kbd> <kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">‚Üí</kbd> Siblings</div>
<div><kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">H</kbd> Home (Root)</div>
<div><kbd style="background:rgba(77,217,204,.2);padding:2px 4px;border-radius:2px">Scroll</kbd> Zoom</div>
</div>
</div>

<div id="tree"></div>
</div>

<div id="main">
  <!-- LEFT: Voronoi View -->
  <div id="voronoiView">
    <canvas id="canvasVoronoi"></canvas>
    <div style="position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.8);padding:8px 12px;border-radius:4px;border:1px solid rgba(77,217,204,0.4)">
      <div style="font-size:10px;color:#4dd9cc;font-weight:bold">üåä VORONOI</div>
    </div>
  </div>
  
  <!-- RIGHT: Sediment View -->
  <div id="sedimentView">
    <canvas id="canvasSediment"></canvas>
    <div style="position:absolute;top:10px;left:10px;background:rgba(0,0,0,0.8);padding:8px 12px;border-radius:4px;border:1px solid rgba(232,184,73,0.4)">
      <div style="font-size:10px;color:#e8b849;font-weight:bold">üèîÔ∏è SEDIMENT</div>
    </div>
  </div>
</div>

<div class="info-panel" id="info" style="display:none"></div>

<div class="territory-panel" id="territoryPanel">
<div class="core-header">‚ö´ CORE SAMPLE</div>
<div id="territoryContent"></div>
</div>

<script>
// DOUBLE BARREL SETUP - Two canvases, one data source
const CAN_VORONOI = document.getElementById('canvasVoronoi');
const CTX_VORONOI = CAN_VORONOI.getContext('2d');
const CAN_SEDIMENT = document.getElementById('canvasSediment');
const CTX_SEDIMENT = CAN_SEDIMENT.getContext('2d');

// Legacy references for existing code
const CAN = CAN_VORONOI;
const CTX = CTX_VORONOI;

let W, H;
let DPR = window.devicePixelRatio || 1;

const STATE={
nodes:[],
nodeMap:{},
root:null,
speciesFilter:'all', // 'all' or specific extension like 'png'
allSpecies:new Set(), // Track all species types
current:null,
maxDepth:0,
path:[], // Full path of nodes from root to current
cameFrom:null, // Node we just navigated from (highlight it)
hoveredNode:null, // Node currently hovered
camera:{
scale:1,
tx:0,
ty:0,
targetScale:1,
targetTx:0,
targetTy:0
},
sedimentCamera:{ // Independent camera for sediment view
scale:1,
tx:0,
ty:0,
targetScale:1,
targetTx:0,
targetTy:0
},
animating:false,
sedimentAnimating:false,
cellCache:{}, // Cache Voronoi cells so they don't regenerate
showFileTree:false // Toggle for file tree panel
};

const DEPTH_COLORS=[
'#4dd9cc','#6be8df','#6bbd8f','#e8b849','#d97b8f','#9d7be8',
'#4dd9cc','#6be8df','#6bbd8f','#e8b849','#d97b8f','#9d7be8'
];

const COLORS={
  jpg:'#d97b8f',png:'#d97b8f',mp4:'#e8b849',mp3:'#9d7be8',
  json:'#6bbd8f',py:'#4dd9cc',txt:'#6b8a96',html:'#4dd9cc',
  wav:'#9d7be8',gif:'#d97b8f',pdf:'#e8b849'
};

function noise(x,y,seed=0){
const n=Math.sin(x*12.9898+y*78.233+seed)*43758.5453;
return n-Math.floor(n);
}

async function loadRealData(){
try{
console.log('Loading ARKADU data...');
const r=await fetch('sys/primitive.jsonl');
const t=await r.text();
const artifacts=t.trim().split('\n').map(l=>JSON.parse(l));
console.log(`Loaded ${artifacts.length} artifacts`);

buildHierarchyFromArtifacts(artifacts);
}catch(e){
console.error('Error loading data:',e);
alert('Could not load primitive.jsonl. Using mock data.');
generateStructure(9);
}
}

function buildHierarchyFromArtifacts(artifacts){
STATE.nodes=[];
STATE.nodeMap={};

// Build chambers from artifact paths (directories)
artifacts.forEach(art=>{
const parts=art.path.split('/');
// Build directory nodes
for(let d=0;d<parts.length-1;d++){
const id=parts.slice(0,d+1).join('/');
if(!STATE.nodeMap[id]){
STATE.nodeMap[id]={
id:id,
name:parts[d],
depth:d,
parent:d>0?parts.slice(0,d).join('/'):null,
children:[],
artifacts:[],
totalFiles:0,
totalSize:0,
species:{},
kingdom:parts[0]||'ROOT',
created:art.created||'unknown',
modified:art.modified||'unknown',
isDirectory:true
};
}
}

// Create node for the ARTIFACT ITSELF as deepest leaf
const artifactId=art.path;
const fileName=parts[parts.length-1];
const parentDirId=parts.slice(0,-1).join('/');
const ext=(art.ext||'').replace(/^\./,'')||'unknown';

STATE.nodeMap[artifactId]={
id:artifactId,
name:fileName,
depth:parts.length-1,
parent:parentDirId,
children:[],
artifacts:[art],
fileCount:1,
totalFiles:1,
size:art.size||0,
totalSize:art.size||0,
totalBytes:art.size||0,
species:{[ext]:{count:1,bytes:art.size||0,color:getColorForExt(ext)}},
kingdom:parts[0]||'ROOT',
created:art.created||'unknown',
modified:art.modified||'unknown',
isDirectory:false,
ext:ext,
artifact:art
};

// Add artifact node as child of parent directory
if(STATE.nodeMap[parentDirId]){
if(!STATE.nodeMap[parentDirId].children.includes(artifactId)){
STATE.nodeMap[parentDirId].children.push(artifactId);
}
STATE.nodeMap[parentDirId].artifacts.push(art);
if(!STATE.nodeMap[parentDirId].species[ext]){
STATE.nodeMap[parentDirId].species[ext]={count:0,color:getColorForExt(ext)};
}
STATE.nodeMap[parentDirId].species[ext].count++;
}
});

// Build parent-child relationships
Object.values(STATE.nodeMap).forEach(ch=>{
if(ch.parent&&STATE.nodeMap[ch.parent]){
const p=STATE.nodeMap[ch.parent];
if(!p.children.includes(ch.id)){
p.children.push(ch.id);
}
}
});

// Aggregate counts recursively
function aggregate(node){
node.fileCount=node.artifacts.length;
node.totalFiles=node.artifacts.length;
node.size=node.artifacts.reduce((s,a)=>s+(a.size||0),0);
node.totalBytes=node.size; // Track bytes separately
node.totalSize=node.size; // Will be recalculated as weighted

node.children.forEach(cid=>{
const child=STATE.nodeMap[cid];
if(child){
aggregate(child);
node.totalFiles+=child.totalFiles;
node.totalBytes+=child.totalBytes;
// Merge species with byte tracking
Object.entries(child.species).forEach(([ext,data])=>{
if(!node.species[ext]){
node.species[ext]={count:0,bytes:0,color:data.color};
}
node.species[ext].count+=data.count;
node.species[ext].bytes+=(data.bytes||0);
});
}
});

// Calculate combined weight: file count + normalized bytes
// Use MB as the unit: count + (bytes / 1MB)
// This balances file count with file size
const MB=1024*1024;
node.totalSize=node.totalFiles+(node.totalBytes/MB);

// Calculate DENSITY metrics
// Density = how concentrated files are in this territory
const maxDepthBelow=Math.max(...(node.children.map(cid=>STATE.nodeMap[cid]?.depth||node.depth).concat([node.depth])));
const depthSpan=maxDepthBelow-node.depth+1; // How many levels deep
node.density={
filesPerLevel:node.totalFiles/depthSpan, // High = concentrated, Low = spread out
branchingFactor:node.children.length>0?node.totalFiles/node.children.length:node.totalFiles, // Avg files per child
avgFileSize:node.totalFiles>0?node.totalBytes/node.totalFiles:0, // Bytes per file
depthSpan:depthSpan
};

// Find dominant species by combined metric (count * bytes)
let dominantExt=null;
let maxWeight=0;
Object.entries(node.species).forEach(([ext,data])=>{
const weight=data.count*(data.bytes||1);
if(weight>maxWeight){
maxWeight=weight;
dominantExt=ext;
}
});

if(dominantExt){
node.dominantSpecies=dominantExt;
node.dominantColor=node.species[dominantExt].color;
node.dominantPct=((node.species[dominantExt].count/node.totalFiles)*100).toFixed(1);
}else{
node.dominantSpecies=null;
node.dominantColor=null;
node.dominantPct=0;
}
}

STATE.nodes=Object.values(STATE.nodeMap);
const rootNodes=STATE.nodes.filter(n=>!n.parent);

// Create virtual ROOT if multiple top-level
if(rootNodes.length>1){
STATE.root={
id:'ROOT',
name:'ROOT',
depth:0,
parent:null,
children:rootNodes.map(n=>n.id),
artifacts:[],
fileCount:0,
totalFiles:0,
size:0,
totalSize:0,
species:{},
kingdom:'ROOT',
created:'',
modified:''
};
rootNodes.forEach(n=>{
n.parent='ROOT';
n.depth++;
// Recursively increment depth
function incrementDepth(node){
node.children.forEach(cid=>{
const child=STATE.nodeMap[cid];
if(child){
child.depth++;
incrementDepth(child);
}
});
}
incrementDepth(n);
});
STATE.nodeMap['ROOT']=STATE.root;
STATE.nodes.push(STATE.root);
}else{
STATE.root=rootNodes[0];
}

aggregate(STATE.root);

// Calculate percentages
function calcPercentages(node,parentTotal){
node.percentage=(node.totalSize/parentTotal*100).toFixed(1);
node.children.forEach(cid=>{
const child=STATE.nodeMap[cid];
if(child)calcPercentages(child,node.totalSize);
});
}
calcPercentages(STATE.root,STATE.root.totalSize);

STATE.maxDepth=Math.max(...STATE.nodes.map(n=>n.depth));

console.log(`Built ${STATE.nodes.length} nodes, max depth: ${STATE.maxDepth}`);
updateStats();
buildTree();
populateSpeciesDropdown();
viewRoot();
}

function getColorForExt(ext){
const colors={
jpg:'#d97b8f',jpeg:'#d97b8f',png:'#d97b8f',gif:'#d97b8f',webp:'#d97b8f',
mp4:'#e8b849',mov:'#e8b849',avi:'#e8b849',webm:'#e8b849',
mp3:'#9d7be8',wav:'#9d7be8',flac:'#9d7be8',ogg:'#9d7be8',
json:'#6bbd8f',txt:'#6bbd8f',md:'#6bbd8f',
py:'#4dd9cc',js:'#4dd9cc',html:'#4dd9cc',css:'#4dd9cc'
};
return colors[ext]||'#6b8a96';
}

function generateStructure(maxDepth){
console.log(`Generating ${maxDepth} layer MOCK structure...`);
STATE.nodes=[];
STATE.nodeMap={};
STATE.maxDepth=maxDepth;

let idCounter=0;
function createNode(name,depth,parent=null){
const id=`node_${idCounter++}`;
const childCount=depth<maxDepth?Math.floor(2+noise(idCounter,depth,1)*3):0;
const size=100+noise(idCounter,depth,2)*1000;

// Generate mock data (in real version, load from ARKADU)
const fileCount=Math.floor(10+noise(idCounter,depth,3)*500);
const species=generateSpecies(idCounter,depth);
const kingdom=depth===0?'ROOT':['CAT','DOG','JELLYFISH','HORSE','DUCK','BIRD'][idCounter%6];

const node={
id,name,depth,parent,
children:[],
size,
totalSize:size,
percentage:0,
// Data fields
fileCount,
totalFiles:fileCount,
species,
kingdom,
created:new Date(Date.now()-Math.random()*365*24*60*60*1000).toISOString().split('T')[0],
modified:new Date(Date.now()-Math.random()*30*24*60*60*1000).toISOString().split('T')[0]
};

STATE.nodeMap[id]=node;
STATE.nodes.push(node);

// Create children recursively
for(let i=0;i<childCount;i++){
const childName=`${name}.${String.fromCharCode(65+i)}`;
const child=createNode(childName,depth+1,id);
node.children.push(child.id);
node.totalSize+=child.totalSize;
}

return node;
}

STATE.root=createNode('ROOT',0);

// Calculate percentages
function generateSpecies(seed,depth){
const types=['jpg','png','mp4','mp3','json','py','txt','md','html'];
const colors={'jpg':'#d97b8f','png':'#d97b8f','mp4':'#e8b849','mp3':'#9d7be8',
'json':'#6bbd8f','py':'#4dd9cc','txt':'#6b8a96','md':'#6b8a96','html':'#4dd9cc'};

const species={};
types.forEach((type,i)=>{
const count=Math.floor(noise(seed,i,depth)*200);
if(count>5){
species[type]={count,color:colors[type]||'#6b8a96'};
}
});
return species;
}

function calcPercentages(node,parentTotal){
node.percentage=(node.totalSize/parentTotal*100).toFixed(1);
node.children.forEach(cid=>{
const child=STATE.nodeMap[cid];
calcPercentages(child,node.totalSize);
// Aggregate file counts
node.totalFiles+=child.totalFiles;
});
}
calcPercentages(STATE.root,STATE.root.totalSize);

console.log(`Generated ${STATE.nodes.length} nodes at ${maxDepth} depths`);
updateStats();
buildTree();
populateSpeciesDropdown();
viewRoot();
}

function buildTree(){
const tree=document.getElementById('tree');
let html='';

// Add breadcrumb trail
if(STATE.path.length>0){
html+=`<div style="background:rgba(77,217,204,0.1);padding:10px;margin-bottom:10px;border-radius:5px;font-size:10px">`;
html+=`<div style="color:#6b8a96;margin-bottom:5px;font-size:9px">üìç CURRENT PATH</div>`;
STATE.path.forEach((node,i)=>{
const isLast=i===STATE.path.length-1;
const sep=isLast?'':`<span style="color:#6b8a96"> ‚Üí </span>`;
if(isLast){
html+=`<span style="color:#e8b849;font-weight:bold">${node.name}</span>`;
}else{
html+=`<a href="#" onclick="viewNode('${node.id}');return false" style="color:#4dd9cc;text-decoration:none">${node.name}</a>${sep}`;
}
});
html+=`</div>`;
}

// Build set of nodes in current path for highlighting
const pathIds=new Set(STATE.path.map(n=>n.id));
const expandedIds=new Set(STATE.path.map(n=>n.id));

function renderNode(node,isInPath=false){
const hasChildren=node.children.length>0;
const indent=node.depth*12;
const cls=['tree-item',`depth-${node.depth}`];
if(hasChildren)cls.push('has-children');
if(node===STATE.current)cls.push('active');

const inPath=pathIds.has(node.id);
const style=inPath?'border-left:2px solid #e8b849;padding-left:6px':'';

html+=`<div class="${cls.join(' ')}" style="margin-left:${indent}px;${style}" 
onclick="viewNode('${node.id}');event.stopPropagation()">`;

// Show species icon if available
let icon='';
if(node.dominantSpecies){
icon=`<span style="color:${node.dominantColor};font-size:8px">.${node.dominantSpecies}</span> `;
}

html+=`${icon}${node.name} <span style="opacity:0.6;font-size:9px">(${node.totalFiles}f, ${node.percentage}%)</span>`;
html+=`</div>`;
}

function traverse(nodeId,depth=0){
const node=STATE.nodeMap[nodeId];
if(!node)return;

const inPath=pathIds.has(node.id);
renderNode(node,inPath);

// Expand if: in current path, or current node's children, or shallow depth
const shouldExpand=inPath||node===STATE.current||depth<2;
if(shouldExpand&&node.children.length>0){
node.children.forEach(cid=>traverse(cid,depth+1));
}
}

traverse(STATE.root.id);
tree.innerHTML=html;

// Scroll to current node
const activeEl=tree.querySelector('.tree-item.active');
if(activeEl){
activeEl.scrollIntoView({behavior:'smooth',block:'center'});
}
}

function viewRoot(){
STATE.cameFrom=STATE.current; // Remember where we came from
STATE.current=STATE.root;
STATE.path=[STATE.root];
const boundary={x:W/2,y:H/2,radius:Math.min(W,H)*0.42};
layoutChildrenInCircle(STATE.root,boundary);

// Reset camera to root view
STATE.camera.targetScale=1;
STATE.camera.targetTx=0;
STATE.camera.targetTy=0;
animateCameraToTarget();

updateStats();
buildTree();
render(); // Force immediate render
}

function viewNode(id){
const node=STATE.nodeMap[id];
if(!node)return;

STATE.cameFrom=STATE.current; // Remember where we came from
STATE.current=node;

// Build full path from root to this node
STATE.path=[];
let n=node;
while(n){
STATE.path.unshift(n);
n=n.parent?STATE.nodeMap[n.parent]:null;
}

// First, layout this node's children if it has any (with caching)
if(node.children.length>0){
// Check if we already have cached cells for this node's children
const cacheKey = node.id;
const childrenNeedLayout = node.children.some(cid => !STATE.nodeMap[cid].cell);

if(childrenNeedLayout || !STATE.cellCache[cacheKey]){
  // Need to generate cells
  if(node.cell){
    // Node has irregular cell - use it as boundary for children
    layoutChildrenInPolygon(node,node.cell);
  }else{
    // Root node - use circle
    const boundary={x:W/2,y:H/2,radius:Math.min(W,H)*0.42};
    layoutChildrenInCircle(node,boundary);
  }
  // Mark as cached
  STATE.cellCache[cacheKey] = true;
}
}

// ALWAYS zoom camera to frame the current node
if(node.cell){
// Non-root: Zoom to this territory's cell
zoomToCell(node.cell);
}else if(node===STATE.root){
// Root: Reset to full view
STATE.camera.targetScale=1;
STATE.camera.targetTx=0;
STATE.camera.targetTy=0;
animateCameraToTarget();
}else if(node.boundary){
// Has boundary (circle) - zoom to it
zoomToBoundary(node.boundary);
}

updateStats();
buildTree();
render(); // Force immediate render
}

function cellsOverlap(cell1,cell2){
// Check if two polar cells overlap by testing vertices
if(!cell1||!cell2)return false;
if(!cell1.angles||!cell2.angles)return false;

// Sample points from cell1 and check if any are inside cell2
for(let i=0;i<cell1.angles.length;i++){
const px=cell1.cx+Math.cos(cell1.angles[i])*cell1.radii[i];
const py=cell1.cy+Math.sin(cell1.angles[i])*cell1.radii[i];

// Check if point is inside cell2
let inside=true;
for(let j=0;j<cell2.angles.length;j++){
const a2=cell2.angles[j];
const r2=cell2.radii[j];
const dx=px-cell2.cx;
const dy=py-cell2.cy;
const angle=Math.atan2(dy,dx);
const dist=Math.sqrt(dx*dx+dy*dy);
// Simplified check - if point is very close to cell2 center, potential overlap
if(dist<r2*0.3)return true;
}
}
return false;
}

function layoutChildrenInCircle(parent,boundary){
if(parent.children.length===0)return;

let children=parent.children.map(id=>STATE.nodeMap[id]);

// STRICT: Every child MUST get visible space - no exceptions
const parentArea=Math.PI*boundary.radius*boundary.radius;
const minAreaPerChild=50; // Absolute minimum per child to avoid overlap
const areaPerChild=parentArea/children.length;

if(areaPerChild<minAreaPerChild){
const maxChildren=Math.max(1,Math.floor(parentArea/minAreaPerChild));
console.warn(`‚ö†Ô∏è OVERLAP PREVENTION: ${parent.name} can only fit ${maxChildren}/${children.length} children without overlap`);
// Sort by size and keep only the largest
children=[...children].sort((a,b)=>b.totalSize-a.totalSize).slice(0,maxChildren);
}

const totalSize=children.reduce((s,ch)=>s+ch.totalSize,0);

parent.boundary=boundary;

// Sort children by size for better distribution
const sortedChildren=[...children].sort((a,b)=>b.totalSize-a.totalSize);

// Debug logging at root level
if(parent.depth===0){
console.log('ROOT territories:');
sortedChildren.forEach(ch=>{
console.log(`  ${ch.name}: ${ch.totalFiles} files, ${(ch.totalBytes/1024/1024).toFixed(1)}MB, totalSize=${ch.totalSize.toFixed(1)}`);
});
}

const seeds=[];
let angleOffset=0;

sortedChildren.forEach((ch,i)=>{
// Weight: larger territories get more space
const weight=ch.totalSize/totalSize;

// Depth-aware weighting: shallow=dramatic, deep=balanced
const depthFactor=Math.max(0.7,1.0-parent.depth*0.1); // 1.0‚Üí0.9‚Üí0.8‚Üí0.7
const weightExponent=0.4+depthFactor*0.3; // 0.7 at root, 0.47 at depth 5
const normalizedWeight=Math.pow(weight,weightExponent);

// Angle span proportional to size
const angleSpan=(Math.PI*2)*normalizedWeight;
const angle=angleOffset+angleSpan*0.5+noise(i,parent.depth,1)*angleSpan*0.15;

// Distance range also scales with depth
const distRange=depthFactor*0.5; // Smaller range at deeper levels
const minDist=boundary.radius*0.2;
const maxDist=boundary.radius*(0.2+distRange);
const dist=minDist+(maxDist-minDist)*normalizedWeight+noise(i,parent.depth,2)*boundary.radius*0.05;

let sx=boundary.x+Math.cos(angle)*dist;
let sy=boundary.y+Math.sin(angle)*dist;

// CRITICAL: Enforce MUCH larger spacing to prevent ANY overlap
const minSpacing=Math.max(boundary.radius*0.30,20); // 30% of radius or 20px minimum - TRIPLED!
let tooClose=false;
let spacingAttempts=0;

do{
tooClose=false;
for(const existingSeed of seeds){
const d=Math.sqrt((sx-existingSeed.x)**2+(sy-existingSeed.y)**2);
if(d<minSpacing){
tooClose=true;
const ang=Math.atan2(sy-boundary.y,sx-boundary.x)+Math.random()*0.5-0.25;
const newDist=Math.min(boundary.radius*0.6,d+minSpacing);
sx=boundary.x+Math.cos(ang)*newDist;
sy=boundary.y+Math.sin(ang)*newDist;
break;
}
}
spacingAttempts++;
}while(tooClose&&spacingAttempts<5);

seeds.push({
x:sx,
y:sy,
node:ch,
weight:normalizedWeight,
index:i
});

angleOffset+=angleSpan;
});

// ITERATIVE AREA FORCING - converge to exact target areas
const iterations=15; // More iterations = better accuracy
// parentArea already defined above

for(let iter=0;iter<iterations;iter++){
// Generate Voronoi cells with current seed positions
seeds.forEach((seed,i)=>{
const cell=computeVoronoiCellInCircle(seed,seeds,boundary);
seed.node.cell=cell;
seed.node.center={x:seed.x,y:seed.y};

// Measure actual cell area
const actualArea=calculateCellArea(cell);
seed.actualArea=actualArea;
});

// Calculate target areas
seeds.forEach(seed=>{
seed.targetArea=(seed.node.totalSize/totalSize)*parentArea;
});

// Adjust seed positions based on area error
seeds.forEach(seed=>{
const error=(seed.actualArea-seed.targetArea)/seed.targetArea;
const areaRatio=seed.actualArea/seed.targetArea;

// If too large: push seed away from center (contract cell)
// If too small: pull seed toward center (expand cell)
const dx=seed.x-boundary.x;
const dy=seed.y-boundary.y;
const dist=Math.sqrt(dx*dx+dy*dy);

if(dist>0.1){
// Movement strength decreases with iterations for convergence
const moveStrength=0.15*(1-iter/iterations); // 0.15 ‚Üí 0

if(areaRatio>1.05){ // Cell too large
// Push away from center
seed.x+=dx*moveStrength*error;
seed.y+=dy*moveStrength*error;
}else if(areaRatio<0.95){ // Cell too small
// Pull toward center
seed.x+=dx*moveStrength*error;
seed.y+=dy*moveStrength*error;
}
}

// Keep seeds within boundary
const newDist=Math.sqrt((seed.x-boundary.x)**2+(seed.y-boundary.y)**2);
if(newDist>boundary.radius*0.9){
const angle=Math.atan2(seed.y-boundary.y,seed.x-boundary.x);
seed.x=boundary.x+Math.cos(angle)*boundary.radius*0.9;
seed.y=boundary.y+Math.sin(angle)*boundary.radius*0.9;
}
});
}

// Final generation with converged seeds
seeds.forEach(seed=>{
const cell=computeVoronoiCellInCircle(seed,seeds,boundary);
seed.node.cell=cell;
seed.node.center={x:seed.x,y:seed.y};
});

// Log convergence stats
if(parent.depth===0){
console.log('\nüåä AREA CONVERGENCE (after '+iterations+' iterations):');
seeds.forEach(seed=>{
const finalArea=calculateCellArea(seed.node.cell);
const targetArea=(seed.node.totalSize/totalSize)*parentArea;
const errorPct=((finalArea-targetArea)/targetArea*100).toFixed(1);
console.log(`  ${seed.node.name}: ${errorPct}% error (target=${targetArea.toFixed(0)}, actual=${finalArea.toFixed(0)})`);
});
}
}

function layoutChildrenInPolygon(parent,parentPoly){
if(parent.children.length===0)return;

let children=parent.children.map(id=>STATE.nodeMap[id]);

// Calculate parent area
let parentArea=0;
for(let i=0;i<parentPoly.angles.length;i++){
const r1=parentPoly.radii[i];
const r2=parentPoly.radii[(i+1)%parentPoly.angles.length];
const a1=parentPoly.angles[i];
const a2=parentPoly.angles[(i+1)%parentPoly.angles.length];
parentArea+=0.5*r1*r2*Math.sin(a2-a1);
}
parentArea=Math.abs(parentArea);

// STRICT overlap prevention - same as circle layout
const minAreaPerChild=50;
const areaPerChild=parentArea/children.length;
if(areaPerChild<minAreaPerChild){
const maxChildren=Math.max(1,Math.floor(parentArea/minAreaPerChild));
console.warn(`‚ö†Ô∏è OVERLAP PREVENTION: ${parent.name} can only fit ${maxChildren}/${children.length} children`);
children=[...children].sort((a,b)=>b.totalSize-a.totalSize).slice(0,maxChildren);
}

const totalSize=children.reduce((s,ch)=>s+ch.totalSize,0);

// Get bounding box AND calculate polygon centroid
let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
let sumX=0,sumY=0;
for(let i=0;i<parentPoly.angles.length;i++){
const px=parentPoly.cx+Math.cos(parentPoly.angles[i])*parentPoly.radii[i];
const py=parentPoly.cy+Math.sin(parentPoly.angles[i])*parentPoly.radii[i];
minX=Math.min(minX,px);
maxX=Math.max(maxX,px);
minY=Math.min(minY,py);
maxY=Math.max(maxY,py);
sumX+=px;
sumY+=py;
}

// Use polygon centroid (average of vertices) instead of bounding box center
const cx=sumX/parentPoly.angles.length;
const cy=sumY/parentPoly.angles.length;
const r=Math.max(maxX-minX,maxY-minY)/2.5; // Reduced radius for irregular shapes

// Convert parent cell to polygon array first (needed for validation)
const parentPolyPoints=[];
for(let i=0;i<parentPoly.angles.length;i++){
const px=parentPoly.cx+Math.cos(parentPoly.angles[i])*parentPoly.radii[i];
const py=parentPoly.cy+Math.sin(parentPoly.angles[i])*parentPoly.radii[i];
parentPolyPoints.push({x:px,y:py});
}

// Sort children by size for better distribution
const sortedChildren=[...children].sort((a,b)=>b.totalSize-a.totalSize);

// Place seeds within parent bounds - weighted by relative size
const seeds=[];
let angleOffset=0;

sortedChildren.forEach((ch,i)=>{
// Weight: larger territories get more space
const weight=ch.totalSize/totalSize;

// Depth-aware weighting: shallow=dramatic, deep=balanced
const depthFactor=Math.max(0.7,1.0-parent.depth*0.1); // 1.0‚Üí0.9‚Üí0.8‚Üí0.7
const weightExponent=0.4+depthFactor*0.3; // 0.7 at root, 0.47 at depth 5
const normalizedWeight=Math.pow(weight,weightExponent);

// Angle span proportional to size
const angleSpan=(Math.PI*2)*normalizedWeight;
const angle=angleOffset+angleSpan*0.5+noise(i,parent.depth,1)*angleSpan*0.15;

// Distance range also scales with depth
const distRange=depthFactor*0.5; // Smaller range at deeper levels
const minDist=r*0.15;
const maxDist=r*(0.15+distRange);
const dist=minDist+(maxDist-minDist)*normalizedWeight+noise(i,parent.depth,2)*r*0.05;

let sx=cx+Math.cos(angle)*dist;
let sy=cy+Math.sin(angle)*dist;

// Ensure seed is inside parent polygon - if not, move toward centroid
let attempts=0;
while(!pointInPolygon(sx,sy,parentPolyPoints)&&attempts<10){
sx=sx*0.8+cx*0.2; // Move 20% toward centroid
sy=sy*0.8+cy*0.2;
attempts++;
}

// If still outside after attempts, place at centroid
if(!pointInPolygon(sx,sy,parentPolyPoints)){
sx=cx;
sy=cy;
}

// CRITICAL: Enforce MUCH larger spacing to prevent ANY overlap  
const minSpacing=Math.max(r*0.30,20); // 30% of parent size or 20px minimum - TRIPLED!
let tooClose=false;
let spacingAttempts=0;

do{
tooClose=false;
for(const existingSeed of seeds){
const dist=Math.sqrt((sx-existingSeed.x)**2+(sy-existingSeed.y)**2);
if(dist<minSpacing){
tooClose=true;
// Move seed slightly
const angle=Math.atan2(sy-cy,sx-cx)+Math.random()*0.5-0.25;
const newDist=Math.min(r*0.6,dist+minSpacing);
sx=cx+Math.cos(angle)*newDist;
sy=cy+Math.sin(angle)*newDist;
break;
}
}
spacingAttempts++;
}while(tooClose&&spacingAttempts<5);

seeds.push({
x:sx,
y:sy,
node:ch,
weight:normalizedWeight,
index:i
});

angleOffset+=angleSpan;
});

// ITERATIVE AREA FORCING for polygons
const iterations=15;
const centroid={x:cx,y:cy};

for(let iter=0;iter<iterations;iter++){
// Generate Voronoi cells with current seed positions
seeds.forEach(seed=>{
const cell=computeVoronoiCellInPolygon(seed,seeds,parentPolyPoints);
seed.node.cell=cell;
seed.node.center={x:seed.x,y:seed.y};
seed.actualArea=calculateCellArea(cell);
});

// Calculate target areas
seeds.forEach(seed=>{
seed.targetArea=(seed.node.totalSize/totalSize)*parentArea;
});

// Adjust seed positions based on area error
seeds.forEach(seed=>{
const error=(seed.actualArea-seed.targetArea)/seed.targetArea;
const areaRatio=seed.actualArea/seed.targetArea;

const dx=seed.x-centroid.x;
const dy=seed.y-centroid.y;
const dist=Math.sqrt(dx*dx+dy*dy);

if(dist>0.1){
const moveStrength=0.15*(1-iter/iterations);

if(areaRatio>1.05){
seed.x+=dx*moveStrength*error;
seed.y+=dy*moveStrength*error;
}else if(areaRatio<0.95){
seed.x+=dx*moveStrength*error;
seed.y+=dy*moveStrength*error;
}
}

// Keep seeds inside parent polygon
if(!pointInPolygon(seed.x,seed.y,parentPolyPoints)){
seed.x=seed.x*0.8+centroid.x*0.2;
seed.y=seed.y*0.8+centroid.y*0.2;
}
});
}

// Final generation with converged seeds
seeds.forEach(seed=>{
const cell=computeVoronoiCellInPolygon(seed,seeds,parentPolyPoints);
seed.node.cell=cell;
seed.node.center={x:seed.x,y:seed.y};
});
}

function computeVoronoiCellInCircle(seed,allSeeds,boundary){
const samples=48;
const points=[];

for(let i=0;i<samples;i++){
const angle=(i/samples)*Math.PI*2;
let dist=0;

for(let step=1;step<120;step++){
const testDist=step*4;
const px=seed.x+Math.cos(angle)*testDist;
const py=seed.y+Math.sin(angle)*testDist;

// Check circle boundary
const d=Math.sqrt((px-boundary.x)**2+(py-boundary.y)**2);
if(d>boundary.radius*0.98){
dist=testDist*0.9;
break;
}

// Check Voronoi boundary
let closestSeed=seed;
let minDist=Infinity;
allSeeds.forEach(s=>{
const d=Math.sqrt((px-s.x)**2+(py-s.y)**2);
if(d<minDist){
minDist=d;
closestSeed=s;
}
});

if(closestSeed!==seed){
dist=testDist*0.9;
break;
}

if(step===119)dist=testDist;
}

points.push({angle,dist});
}

// Smooth
const smoothed=[];
for(let i=0;i<points.length;i++){
const prev=points[(i-1+points.length)%points.length];
const curr=points[i];
const next=points[(i+1)%points.length];
const smoothDist=(prev.dist+curr.dist*2+next.dist)/4;
smoothed.push({angle:curr.angle,dist:smoothDist});
}

return{
cx:seed.x,
cy:seed.y,
angles:smoothed.map(p=>p.angle),
radii:smoothed.map(p=>p.dist)
};
}

function computeVoronoiCellInPolygon(seed,allSeeds,parentPoly){
const samples=48;
const points=[];

// Calculate parent polygon bounding box to determine appropriate step size
let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
parentPoly.forEach(p=>{minX=Math.min(minX,p.x);maxX=Math.max(maxX,p.x);minY=Math.min(minY,p.y);maxY=Math.max(maxY,p.y);});
const parentSize=Math.max(maxX-minX,maxY-minY);

// Adaptive step size: smaller for smaller parents
const stepSize=Math.max(0.5,parentSize/100);
const maxSteps=Math.ceil(parentSize/stepSize);

for(let i=0;i<samples;i++){
const angle=(i/samples)*Math.PI*2;
let dist=0;

for(let step=1;step<maxSteps;step++){
const testDist=step*stepSize;
const px=seed.x+Math.cos(angle)*testDist;
const py=seed.y+Math.sin(angle)*testDist;

// Check if inside parent polygon
if(!pointInPolygon(px,py,parentPoly)){
dist=testDist*0.9;
break;
}

// Check Voronoi boundary
let closestSeed=seed;
let minDist=Infinity;
allSeeds.forEach(s=>{
const d=Math.sqrt((px-s.x)**2+(py-s.y)**2);
if(d<minDist){
minDist=d;
closestSeed=s;
}
});

if(closestSeed!==seed){
dist=testDist*0.9;
break;
}

if(step===maxSteps-1)dist=testDist;
}

points.push({angle,dist});
}

// Smooth
const smoothed=[];
for(let i=0;i<points.length;i++){
const prev=points[(i-1+points.length)%points.length];
const curr=points[i];
const next=points[(i+1)%points.length];
const smoothDist=(prev.dist+curr.dist*2+next.dist)/4;
smoothed.push({angle:curr.angle,dist:smoothDist});
}

return{
cx:seed.x,
cy:seed.y,
angles:smoothed.map(p=>p.angle),
radii:smoothed.map(p=>p.dist)
};
}

function pointInPolygon(x,y,poly){
let inside=false;

// Handle both formats: cell {cx,cy,angles,radii} or points array [{x,y}]
if(Array.isArray(poly)){
// Points array format
for(let i=0,j=poly.length-1;i<poly.length;j=i++){
const xi=poly[i].x;
const yi=poly[i].y;
const xj=poly[j].x;
const yj=poly[j].y;
if(((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi)+xi)){
inside=!inside;
}
}
}else{
// Cell format
const {cx,cy,angles,radii}=poly;
for(let i=0,j=angles.length-1;i<angles.length;j=i++){
const xi=cx+Math.cos(angles[i])*radii[i];
const yi=cy+Math.sin(angles[i])*radii[i];
const xj=cx+Math.cos(angles[j])*radii[j];
const yj=cy+Math.sin(angles[j])*radii[j];

if(((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi)+xi)){
inside=!inside;
}
}
}

return inside;
}

function render(){
CTX.fillStyle='#0a0e1a';
CTX.fillRect(0,0,W*DPR,H*DPR);

CTX.save();
CTX.scale(DPR,DPR);

// Apply camera transform
CTX.translate(STATE.camera.tx,STATE.camera.ty);
CTX.scale(STATE.camera.scale,STATE.camera.scale);

// Calculate inverse scale for consistent screen-space sizing
const invScale=1/STATE.camera.scale;

if(!STATE.current)return;

// Draw ENTIRE PATH of parent shapes (visual breadcrumb trail) - but only at shallow depths
if(STATE.path.length>1&&STATE.current.depth<=3){
for(let i=0;i<STATE.path.length-1;i++){
const ancestor=STATE.path[i];
const depth=i;
const opacity=Math.max(0.1,0.5-depth*0.08);

if(ancestor.cell){
const color=DEPTH_COLORS[ancestor.depth%DEPTH_COLORS.length];
const alpha=opacity*0.5;
drawCell(ancestor.cell,color,alpha);

// Faint border
CTX.strokeStyle=hexToRgba(color,opacity);
CTX.lineWidth=0.3*invScale;
CTX.setLineDash([2*invScale,2*invScale]);
drawCellBorder(ancestor.cell);
CTX.setLineDash([]);
}
}
}

// Draw current parent boundary - only at shallow depths
if(STATE.current.depth<=2){
if(STATE.current.cell){
const pc=STATE.current.cell;
CTX.strokeStyle='rgba(77,217,204,0.2)';
CTX.lineWidth=0.5*invScale;
CTX.setLineDash([4*invScale,2*invScale]);
CTX.beginPath();
for(let i=0;i<pc.angles.length;i++){
const px=pc.cx+Math.cos(pc.angles[i])*pc.radii[i];
const py=pc.cy+Math.sin(pc.angles[i])*pc.radii[i];
if(i===0)CTX.moveTo(px,py);
else CTX.lineTo(px,py);
}
CTX.closePath();
CTX.stroke();
CTX.setLineDash([]);
}else if(STATE.current.boundary){
// Root - draw circle
CTX.strokeStyle='rgba(77,217,204,0.2)';
CTX.lineWidth=0.5*invScale;
CTX.setLineDash([4*invScale,2*invScale]);
CTX.beginPath();
const r=Math.min(W,H)*0.42;
CTX.arc(W/2,H/2,r,0,Math.PI*2);
CTX.stroke();
CTX.setLineDash([]);
}
}

// Draw children cells
const children=STATE.current.children.map(id=>STATE.nodeMap[id]);

// LEAF NODE: Show actual files as scattered artifacts in Voronoi space
if(children.length === 0 && STATE.current.files && STATE.current.files.length > 0){
  const files = STATE.current.files;
  const centerX = W / 2;
  const centerY = H / 2;
  const radius = Math.min(W, H) * 0.35;
  
  files.forEach((file, i) => {
    // Scatter files in a circle pattern
    const angle = (i / files.length) * Math.PI * 2;
    const r = radius * (0.5 + Math.random() * 0.5);
    const x = centerX + Math.cos(angle) * r;
    const y = centerY + Math.sin(angle) * r;
    
    const ext = (file.ext || '').replace('.', '');
    const color = COLORS[ext] || '#6b8a96';
    
    // Draw artifact marker
    CTX.beginPath();
    CTX.arc(x, y, 8 * invScale, 0, Math.PI * 2);
    CTX.fillStyle = hexToRgba(color, 0.6);
    CTX.fill();
    CTX.strokeStyle = color;
    CTX.lineWidth = 2 * invScale;
    CTX.stroke();
    
    // Extension label
    CTX.fillStyle = color;
    CTX.font = `bold ${10 * invScale}px monospace`;
    CTX.textAlign = 'center';
    CTX.fillText(ext, x, y - 12 * invScale);
  });
  
  // Center label
  CTX.fillStyle = '#4dd9cc';
  CTX.font = `bold ${14 * invScale}px monospace`;
  CTX.textAlign = 'center';
  CTX.fillText(`üìÅ ${files.length} ARTIFACTS`, centerX, centerY);
  
  CTX.restore();
  return;
}

// Sort by size to find top 3 biggest
const childrenBySize=[...children].sort((a,b)=>b.totalSize-a.totalSize);
const top3Biggest=new Set(childrenBySize.slice(0,3));

children.forEach((ch,idx)=>{
if(!ch.cell)return;

// Filter by species
if(!nodeMatchesFilter(ch)){
// Render filtered-out territories as faded/dimmed
const fadedColor='rgba(77,217,204,0.03)';
CTX.fillStyle=fadedColor;
CTX.beginPath();
for(let i=0;i<ch.cell.angles.length;i++){
const px=ch.cell.cx+Math.cos(ch.cell.angles[i])*ch.cell.radii[i];
const py=ch.cell.cy+Math.sin(ch.cell.angles[i])*ch.cell.radii[i];
if(i===0)CTX.moveTo(px,py);
else CTX.lineTo(px,py);
}
CTX.closePath();
CTX.fill();
return; // Skip full rendering
}

// Base depth color
let color=DEPTH_COLORS[ch.depth%DEPTH_COLORS.length];

// Blend with dominant species color if available
if(ch.dominantColor&&ch.dominantPct>0){
const tintStrength=Math.min(0.6,ch.dominantPct/100*0.8); // Max 60% tint
color=blendColors(color,ch.dominantColor,tintStrength);
}

// DENSITY ENCODING: Adjust brightness based on file concentration
if(ch.density){
// Normalize density (log scale for better distribution)
const globalAvgDensity=100; // Rough baseline
const densityRatio=Math.log(ch.density.filesPerLevel+1)/Math.log(globalAvgDensity+1);
const brightnessFactor=Math.min(1.4,Math.max(0.6,0.8+densityRatio*0.4)); // 0.6 to 1.4

// Adjust color brightness
color=adjustBrightness(color,brightnessFactor);
}

const isCameFrom=ch===STATE.cameFrom;
const isHovered=ch===STATE.hoveredNode;
const alpha=isCameFrom?0.4:0.25;

// Fill
drawCell(ch.cell,color,alpha);

// Border - multiply by invScale to keep constant screen size
if(isCameFrom){
CTX.shadowColor=color;
CTX.shadowBlur=8*invScale;
CTX.strokeStyle=color;
CTX.lineWidth=1.5*invScale;
drawCellBorder(ch.cell);
CTX.shadowBlur=0;
}else if(isHovered){
CTX.shadowColor=color;
CTX.shadowBlur=6*invScale;
CTX.strokeStyle=color;
CTX.lineWidth=1*invScale;
drawCellBorder(ch.cell);
CTX.shadowBlur=0;
}else{
CTX.strokeStyle=color;
CTX.lineWidth=0.5*invScale;
drawCellBorder(ch.cell);
}

// Label strategy:
// - Crowded level (>20 children): hover only
// - Shallow depths (0-2): show all
// - Medium depth: show top 3 biggest
// - Always show cameFrom breadcrumb
const minRadius=Math.max(...ch.cell.radii);
const isCrowded=children.length>20;
const isShallowDepth=STATE.current.depth<=2;
const isTop3=top3Biggest.has(ch);
const isLargeEnough=minRadius*STATE.camera.scale>15;

let showLabel=false;
if(isLargeEnough){
if(isCrowded){
// Crowded: only hover or breadcrumb
showLabel=isCameFrom||isHovered;
}else if(isShallowDepth){
// Shallow: show all
showLabel=true;
}else{
// Medium: top 3 + hover + breadcrumb
showLabel=isTop3||isCameFrom||isHovered;
}
}

if(showLabel){
CTX.fillStyle=color;

// Font size - multiply by invScale to stay constant on screen
const baseFontSize=isCameFrom?11:10;
CTX.font=`bold ${baseFontSize*invScale}px monospace`;
CTX.textAlign='center';
CTX.textBaseline='middle';

if(isCameFrom||isHovered){
CTX.shadowColor=color;
CTX.shadowBlur=6*invScale;
}
CTX.fillText(ch.name,ch.center.x,ch.center.y-8*invScale);
CTX.shadowBlur=0;

if(ch.percentage){
CTX.font=`${8*invScale}px monospace`;
CTX.fillStyle='rgba(107,138,150,0.8)';
CTX.fillText(`${ch.percentage}%`,ch.center.x,ch.center.y+4*invScale);
}

if(ch.children.length>0){
CTX.fillStyle=color;
CTX.font=`${8*invScale}px monospace`;
CTX.fillText(`${ch.children.length} ‚Üí`,ch.center.x,ch.center.y+14*invScale);
}

if(isCameFrom){
// Add "you were here" indicator
CTX.fillStyle=color;
CTX.font=`${8*invScale}px monospace`;
CTX.fillText('‚¨Ü FROM HERE',ch.center.x,ch.center.y+24*invScale);
}
}
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 3D TERRAIN EXTRUSION - Voronoi cells through sediment layers
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if(showSedimentLayer && children.length > 0){
  // Calculate sediment layers (depth-based strata)
  const totalWeight = children.reduce((sum, ch) => sum + (ch.totalSize || 100), 0);
  const numLayers = Math.min(children.length, 8); // Max 8 visible layers
  const layerHeight = (H * 0.7) / numLayers;
  
  // Sort children by weight to create strata
  const sortedChildren = [...children].sort((a, b) => (b.totalSize || 100) - (a.totalSize || 100));
  
  // Draw each Voronoi cell as extruded 3D column through layers
  children.forEach((ch, idx) => {
    if(!ch.cell) return;
    
    const color = ch.dominantColor || DEPTH_COLORS[ch.depth % DEPTH_COLORS.length];
    const cellWeight = ch.totalSize || 100;
    const heightRatio = cellWeight / totalWeight;
    
    // Calculate extrusion height (how many layers this cell penetrates)
    const extrusionLayers = Math.ceil(heightRatio * numLayers);
    const baseY = H * 0.15; // Start height
    
    // Draw extruded column (isometric 3D effect)
    for(let layer = 0; layer < extrusionLayers; layer++){
      const layerY = baseY + (layer * layerHeight);
      const layerAlpha = 0.3 - (layer * 0.03); // Fade with depth
      const offset = layer * 3; // Isometric offset
      
      // Draw cell at this layer with offset for 3D effect
      CTX.save();
      CTX.translate(offset, offset);
      
      // Cell face
      CTX.fillStyle = hexToRgba(color, layerAlpha);
      CTX.beginPath();
      for(let i = 0; i < ch.cell.angles.length; i++){
        const px = ch.cell.cx + Math.cos(ch.cell.angles[i]) * ch.cell.radii[i];
        const py = ch.cell.cy + Math.sin(ch.cell.angles[i]) * ch.cell.radii[i];
        const adjustedY = py * 0.3 + layerY; // Flatten Y for isometric
        if(i === 0) CTX.moveTo(px, adjustedY);
        else CTX.lineTo(px, adjustedY);
      }
      CTX.closePath();
      CTX.fill();
      
      // Cell border
      CTX.strokeStyle = hexToRgba(color, layerAlpha + 0.2);
      CTX.lineWidth = 1;
      CTX.stroke();
      
      // Draw connecting edges to previous layer (3D walls)
      if(layer > 0){
        const prevLayerY = baseY + ((layer - 1) * layerHeight);
        const prevOffset = (layer - 1) * 3;
        
        CTX.strokeStyle = hexToRgba(color, layerAlpha * 0.5);
        CTX.lineWidth = 0.5;
        
        for(let i = 0; i < ch.cell.angles.length; i++){
          const px = ch.cell.cx + Math.cos(ch.cell.angles[i]) * ch.cell.radii[i];
          const py = ch.cell.cy + Math.sin(ch.cell.angles[i]) * ch.cell.radii[i];
          
          const currentY = py * 0.3 + layerY;
          const prevY = py * 0.3 + prevLayerY;
          
          CTX.beginPath();
          CTX.moveTo(px + prevOffset, prevY);
          CTX.lineTo(px + offset, currentY);
          CTX.stroke();
        }
      }
      
      CTX.restore();
    }
    
    // Top surface label
    const topY = baseY + (extrusionLayers * layerHeight);
    const topOffset = extrusionLayers * 3;
    CTX.fillStyle = color;
    CTX.font = 'bold 9px monospace';
    CTX.textAlign = 'center';
    CTX.fillText(ch.name, ch.center.x + topOffset, ch.center.y * 0.3 + topY - 5);
    
    // Height indicator
    CTX.font = '8px monospace';
    CTX.fillStyle = hexToRgba(color, 0.7);
    CTX.fillText(`${extrusionLayers}L`, ch.center.x + topOffset, ch.center.y * 0.3 + topY + 8);
  });
  
  // Draw layer separators (sediment boundaries)
  CTX.strokeStyle = 'rgba(77,217,204,0.2)';
  CTX.lineWidth = 1;
  CTX.setLineDash([5, 5]);
  for(let layer = 0; layer <= numLayers; layer++){
    const y = baseY + (layer * layerHeight);
    CTX.beginPath();
    CTX.moveTo(0, y);
    CTX.lineTo(W, y);
    CTX.stroke();
    
    // Layer label
    CTX.fillStyle = 'rgba(77,217,204,0.5)';
    CTX.font = '8px monospace';
    CTX.textAlign = 'right';
    CTX.fillText(`Layer ${layer}`, W - 10, y - 3);
  }
  CTX.setLineDash([]);
}

CTX.restore();

// Update info panel
updateInfoPanel();

// DOUBLE BARREL: Also render sediment view
renderSediment();

// Draw crossing flows (Sankey vectors)
drawCrossingFlows();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CROSSING FLOWS - Organic tethered lines between views
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function drawCrossingFlows(){
  if(crossingFlows.length === 0) return;
  
  crossingFlows.forEach(flow => {
    const {fromNode, toNode, mode} = flow;
    if(!fromNode || !toNode) return;
    
    // Get tether points
    const startX = fromNode.center ? fromNode.center.x : W / 4;
    const startY = fromNode.center ? fromNode.center.y : H / 2;
    const endX = W / 2 + (toNode.sedimentBounds ? (toNode.sedimentBounds.xLeft + toNode.sedimentBounds.xRight) / 2 : W / 4);
    const endY = toNode.sedimentBounds ? (toNode.sedimentBounds.yTop + toNode.sedimentBounds.yBottom) / 2 : H / 2;
    
    // Mode colors
    const modeColors = {
      flag: '#e8b849',
      tag: '#9d7be8', 
      measure: '#4dd9cc'
    };
    const color = modeColors[mode] || '#4dd9cc';
    
    CTX.save();
    CTX.scale(DPR, DPR);
    
    // Organic curved line (simple bezier)
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const controlY = midY + Math.sin(startX * 0.1) * 20; // Slight organic wave
    
    CTX.strokeStyle = hexToRgba(color, 0.5);
    CTX.lineWidth = 1.5;
    CTX.beginPath();
    CTX.moveTo(startX, startY);
    CTX.quadraticCurveTo(midX, controlY, endX, endY);
    CTX.stroke();
    
    // Tether dots at endpoints
    CTX.fillStyle = color;
    CTX.beginPath();
    CTX.arc(startX, startY, 3, 0, Math.PI * 2);
    CTX.fill();
    CTX.beginPath();
    CTX.arc(endX, endY, 3, 0, Math.PI * 2);
    CTX.fill();
    
    CTX.restore();
  });
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SEDIMENT RENDERING - Classic horizontal strata (CLEAN)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function renderSediment(){
  CTX_SEDIMENT.fillStyle = '#0a0e1a';
  CTX_SEDIMENT.fillRect(0, 0, W * DPR, H * DPR);
  
  if(!STATE.current) return;
  
  CTX_SEDIMENT.save();
  CTX_SEDIMENT.scale(DPR, DPR);
  
  // Apply SEDIMENT camera transform (independent zoom)
  CTX_SEDIMENT.translate(STATE.sedimentCamera.tx, STATE.sedimentCamera.ty);
  CTX_SEDIMENT.scale(STATE.sedimentCamera.scale, STATE.sedimentCamera.scale);
  
  const children = STATE.current.children.map(id => STATE.nodeMap[id]);
  
  // LEAF NODE: Show actual files as artifact cards
  if(children.length === 0 && STATE.current.files && STATE.current.files.length > 0){
    const files = STATE.current.files;
    const margin = 40;
    const cardWidth = 120;
    const cardHeight = 80;
    const gap = 10;
    const cols = Math.floor((W - margin * 2) / (cardWidth + gap));
    
    CTX_SEDIMENT.fillStyle = '#6b8a96';
    CTX_SEDIMENT.font = 'bold 14px monospace';
    CTX_SEDIMENT.textAlign = 'center';
    CTX_SEDIMENT.fillText(`üìÅ ${files.length} ARTIFACTS`, W / 2, margin - 10);
    
    files.forEach((file, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      const x = margin + col * (cardWidth + gap);
      const y = margin + row * (cardHeight + gap);
      
      // Get file extension color
      const ext = (file.ext || '').replace('.', '');
      const color = COLORS[ext] || '#6b8a96';
      
      // Card background
      CTX_SEDIMENT.fillStyle = hexToRgba(color, 0.2);
      CTX_SEDIMENT.fillRect(x, y, cardWidth, cardHeight);
      
      // Card border
      CTX_SEDIMENT.strokeStyle = color;
      CTX_SEDIMENT.lineWidth = 2;
      CTX_SEDIMENT.strokeRect(x, y, cardWidth, cardHeight);
      
      // File icon/extension
      CTX_SEDIMENT.fillStyle = color;
      CTX_SEDIMENT.font = 'bold 24px monospace';
      CTX_SEDIMENT.textAlign = 'center';
      CTX_SEDIMENT.fillText(ext.toUpperCase(), x + cardWidth / 2, y + 35);
      
      // File size
      CTX_SEDIMENT.font = '9px monospace';
      CTX_SEDIMENT.fillStyle = '#6b8a96';
      const sizeMB = ((file.size || 0) / 1024 / 1024).toFixed(2);
      CTX_SEDIMENT.fillText(`${sizeMB} MB`, x + cardWidth / 2, y + 55);
      
      // File name (truncated)
      const name = file.name || 'unknown';
      const displayName = name.length > 15 ? name.substr(0, 12) + '...' : name;
      CTX_SEDIMENT.font = '8px monospace';
      CTX_SEDIMENT.fillText(displayName, x + cardWidth / 2, y + 70);
    });
    
    CTX_SEDIMENT.restore();
    return;
  }
  
  if(children.length === 0){
    CTX_SEDIMENT.fillStyle = '#6b8a96';
    CTX_SEDIMENT.font = '14px monospace';
    CTX_SEDIMENT.textAlign = 'center';
    CTX_SEDIMENT.fillText('No data at this level', W / 2, H / 2);
    CTX_SEDIMENT.restore();
    return;
  }
  
  // Calculate total weight
  const totalWeight = children.reduce((sum, ch) => sum + (ch.totalSize || 100), 0);
  
  const margin = 80;
  const strataWidth = W - margin * 2;
  
  // CRITICAL: Allow sediment to extend beyond viewport
  // Calculate actual height needed for all layers with minimum spacing
  const minLayerHeight = 40; // Minimum height per layer for readability
  const totalNeededHeight = children.length * minLayerHeight;
  const strataHeight = Math.max(H - margin * 2, totalNeededHeight);
  
  let y = margin + strataHeight; // Start at BOTTOM
  
  children.forEach((layer, i) => {
    const heightRatio = (layer.totalSize || 100) / totalWeight;
    let layerH = Math.max(15, strataHeight * heightRatio);
    
    // COMPRESSION: Cap very large layers but show visual weight
    const maxLayerHeight = 200; // Max height before compression
    let isCompressed = false;
    let compressionRatio = 1;
    
    if(layerH > maxLayerHeight){
      isCompressed = true;
      compressionRatio = layerH / maxLayerHeight;
      layerH = maxLayerHeight; // Compress to max
    }
    
    const yTop = y - layerH;
    
    // Store bounds for click detection
    layer.sedimentBounds = {yTop, yBottom: y, xLeft: margin, xRight: margin + strataWidth};
    
    // Get color
    const color = layer.dominantColor || DEPTH_COLORS[layer.depth % DEPTH_COLORS.length];
    
    // Check if hovered
    const isHovered = layer === STATE.hoveredNode;
    const isCameFrom = layer === STATE.cameFrom;
    
    // Draw wavy strata with organic edges
    CTX_SEDIMENT.fillStyle = hexToRgba(color, isHovered ? 0.85 : 0.6);
    if(isCameFrom){
      CTX_SEDIMENT.shadowColor = '#e8b849';
      CTX_SEDIMENT.shadowBlur = 20;
    }
    
    CTX_SEDIMENT.beginPath();
    CTX_SEDIMENT.moveTo(margin, yTop);
    
    // Wavy top edge
    const segments = 60;
    for(let s = 0; s <= segments; s++){
      const x = margin + (s / segments) * strataWidth;
      const wave1 = Math.sin(s * 0.3 + i * 2) * 12 * noise(s, i);
      const wave2 = Math.sin(s * 0.8 + i * 3) * 6 * noise(s + 100, i);
      const waveY = yTop + wave1 + wave2;
      CTX_SEDIMENT.lineTo(x, waveY);
    }
    
    CTX_SEDIMENT.lineTo(margin + strataWidth, y);
    
    // Wavy bottom edge
    for(let s = segments; s >= 0; s--){
      const x = margin + (s / segments) * strataWidth;
      const wave1 = Math.sin(s * 0.3 + (i - 1) * 2) * 12 * noise(s, i - 1);
      const wave2 = Math.sin(s * 0.8 + (i - 1) * 3) * 6 * noise(s + 100, i - 1);
      const waveY = i === 0 ? y : y + wave1 + wave2;
      CTX_SEDIMENT.lineTo(x, waveY);
    }
    
    CTX_SEDIMENT.closePath();
    CTX_SEDIMENT.fill();
    
    // Border
    CTX_SEDIMENT.globalAlpha = 0.8;
    CTX_SEDIMENT.strokeStyle = color;
    CTX_SEDIMENT.lineWidth = 1;
    CTX_SEDIMENT.stroke();
    CTX_SEDIMENT.shadowBlur = 0;
    
    // COMPRESSION VISUAL INDICATORS
    if(isCompressed){
      // Draw density pattern (horizontal lines showing compression)
      CTX_SEDIMENT.strokeStyle = hexToRgba(color, 0.3);
      CTX_SEDIMENT.lineWidth = 1;
      const numLines = Math.min(15, Math.floor(compressionRatio * 3));
      for(let l = 0; l < numLines; l++){
        const lineY = yTop + (layerH / numLines) * l;
        CTX_SEDIMENT.beginPath();
        CTX_SEDIMENT.moveTo(margin, lineY);
        CTX_SEDIMENT.lineTo(margin + strataWidth, lineY);
        CTX_SEDIMENT.stroke();
      }
      
      // Compression indicator badge
      CTX_SEDIMENT.fillStyle = 'rgba(232,184,73,0.9)';
      CTX_SEDIMENT.fillRect(margin + strataWidth - 80, yTop + 5, 70, 20);
      CTX_SEDIMENT.fillStyle = '#0a0e1a';
      CTX_SEDIMENT.font = 'bold 10px monospace';
      CTX_SEDIMENT.textAlign = 'center';
      CTX_SEDIMENT.fillText(`${compressionRatio.toFixed(1)}√ó DENSE`, margin + strataWidth - 45, yTop + 18);
    }
    
    // Label - only if layer is tall enough
    if(layerH > 25){
      CTX_SEDIMENT.globalAlpha = 1;
      CTX_SEDIMENT.fillStyle = '#fff';
      CTX_SEDIMENT.font = isCameFrom ? 'bold 13px monospace' : '12px monospace';
      CTX_SEDIMENT.textAlign = 'left';
      CTX_SEDIMENT.fillText(layer.name, margin + 20, yTop + layerH / 2 - 8);
      
      // Stats
      CTX_SEDIMENT.font = '10px monospace';
      CTX_SEDIMENT.fillStyle = '#6b8a96';
      const files = layer.totalFiles || 0;
      const mb = ((layer.totalBytes || 0) / 1024 / 1024).toFixed(1);
      CTX_SEDIMENT.fillText(`${files} files ‚Ä¢ ${mb} MB`, margin + 20, yTop + layerH / 2 + 6);
      
      // Percentage (with compression indicator)
      const pct = ((heightRatio * 100).toFixed(1));
      CTX_SEDIMENT.fillStyle = isCompressed ? '#e8b849' : color;
      CTX_SEDIMENT.font = isCompressed ? 'bold 11px monospace' : '9px monospace';
      CTX_SEDIMENT.textAlign = 'right';
      const pctText = isCompressed ? `${pct}% ‚¨á` : `${pct}%`;
      CTX_SEDIMENT.fillText(pctText, margin + strataWidth - (isCompressed ? 90 : 20), yTop + layerH / 2);
    }
    
    y -= layerH;
  });
  
  // Scale labels
  CTX_SEDIMENT.fillStyle = '#6b8a96';
  CTX_SEDIMENT.font = '9px monospace';
  CTX_SEDIMENT.textAlign = 'right';
  CTX_SEDIMENT.fillText('SURFACE', margin - 8, margin + 10);
  CTX_SEDIMENT.fillText('BEDROCK', margin - 8, margin + strataHeight);
  
  CTX_SEDIMENT.restore();
}

function drawCell(cell,color,alpha){
CTX.fillStyle=hexToRgba(color,alpha);
CTX.beginPath();
for(let i=0;i<cell.angles.length;i++){
const px=cell.cx+Math.cos(cell.angles[i])*cell.radii[i];
const py=cell.cy+Math.sin(cell.angles[i])*cell.radii[i];
if(i===0)CTX.moveTo(px,py);
else CTX.lineTo(px,py);
}
CTX.closePath();
CTX.fill();
}

function drawCellBorder(cell){
CTX.beginPath();
for(let i=0;i<cell.angles.length;i++){
const px=cell.cx+Math.cos(cell.angles[i])*cell.radii[i];
const py=cell.cy+Math.sin(cell.angles[i])*cell.radii[i];
if(i===0)CTX.moveTo(px,py);
else CTX.lineTo(px,py);
}
CTX.closePath();
CTX.stroke();
}

function hexToRgba(hex,alpha){
if(!hex)return `rgba(0,0,0,${alpha})`;
const r=parseInt(hex.slice(1,3),16);
const g=parseInt(hex.slice(3,5),16);
const b=parseInt(hex.slice(5,7),16);
return `rgba(${r},${g},${b},${alpha})`;
}

function blendColors(baseHex,tintHex,tintStrength){
// Blend base depth color with dominant species color
const r1=parseInt(baseHex.slice(1,3),16);
const g1=parseInt(baseHex.slice(3,5),16);
const b1=parseInt(baseHex.slice(5,7),16);

const r2=parseInt(tintHex.slice(1,3),16);
const g2=parseInt(tintHex.slice(3,5),16);
const b2=parseInt(tintHex.slice(5,7),16);

const r=Math.round(r1*(1-tintStrength)+r2*tintStrength);
const g=Math.round(g1*(1-tintStrength)+g2*tintStrength);
const b=Math.round(b1*(1-tintStrength)+b2*tintStrength);

return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
}

function adjustBrightness(hexColor,factor){
// Adjust color brightness: factor < 1 = darker, factor > 1 = brighter
const r=parseInt(hexColor.slice(1,3),16);
const g=parseInt(hexColor.slice(3,5),16);
const b=parseInt(hexColor.slice(5,7),16);

// Convert to HSL, adjust lightness, convert back
// Simple approximation: multiply RGB by factor and clamp
const nr=Math.min(255,Math.round(r*factor));
const ng=Math.min(255,Math.round(g*factor));
const nb=Math.min(255,Math.round(b*factor));

return `#${nr.toString(16).padStart(2,'0')}${ng.toString(16).padStart(2,'0')}${nb.toString(16).padStart(2,'0')}`;
}

function updateStats(){
document.getElementById('maxDepth').textContent=STATE.maxDepth;
document.getElementById('totalNodes').textContent=STATE.nodes.length;
document.getElementById('currentView').textContent=STATE.current?STATE.current.name:'ROOT';
// Update HUD
document.getElementById('hudDepth').textContent=`D${STATE.current?STATE.current.depth:0}`;
document.getElementById('totalNodes').textContent=STATE.nodes.length;
document.getElementById('currentView').textContent=STATE.current?STATE.current.name:'ROOT';
document.getElementById('currentDepth').textContent=STATE.current?STATE.current.depth:0;
document.getElementById('childCount').textContent=STATE.current?STATE.current.children.length:0;
}

function updateInfoPanel(){
if(!STATE.current)return;

const node=STATE.current;
let html=`<strong style="color:#4dd9cc;font-size:14px">${node.name}</strong><br><br>`;

// Path breadcrumbs
if(STATE.path.length>1){
html+=`<strong>Path:</strong> `;
STATE.path.forEach((n,i)=>{
if(i>0)html+=` ‚Ä∫ `;
if(n===node){
html+=`<span style="color:#4dd9cc;font-weight:bold">${n.name}</span>`;
}else{
html+=`<span style="color:#6b8a96;cursor:pointer" onclick="viewNode('${n.id}')">${n.name}</span>`;
}
});
html+=`<br><br>`;
}

html+=`Depth: ${node.depth}/${STATE.maxDepth}<br>`;
html+=`<strong>Total Size:</strong> ${node.totalSize.toFixed(0)} units<br>`;
html+=`<span style="font-size:9px;color:#6b8a96">(${node.totalFiles.toLocaleString()} files + ${(node.totalBytes/(1024*1024)).toFixed(1)} MB)</span><br>`;
html+=`Percentage: ${node.percentage}%<br>`;
html+=`Children: ${node.children.length}<br>`;

if(node.children.length>0){
html+=`<br><strong>Breakdown:</strong><br>`;
node.children.slice(0,8).forEach(cid=>{
const child=STATE.nodeMap[cid];
html+=`<span style="cursor:pointer;color:#6bbd8f" onclick="viewNode('${child.id}')">${child.name}</span>: ${child.percentage}%<br>`;
});
if(node.children.length>8){
html+=`... +${node.children.length-8} more<br>`;
}
}

// Add scale verification link
html+=`<br><div style="border-top:1px solid rgba(77,217,204,0.2);padding-top:10px;margin-top:10px">`;
html+=`<div style="font-size:9px;color:#6b8a96">`;
html+=`‚öñÔ∏è <strong style="color:#e8b849">Scale Verified</strong><br>`;
html+=`Measurements validated against <a href="sys/scale-verification.json" target="_blank" style="color:#4dd9cc">scale-verification.json</a><br>`;
html+=`See <a href="SCALE-VERIFICATION.md" target="_blank" style="color:#4dd9cc">documentation</a> for details`;
html+=`</div></div>`;

document.getElementById('info').innerHTML=html;
updateTerritoryPanel();
}

function updateTerritoryPanel(){
if(!STATE.current)return;

const node=STATE.current;
let html='';

// Check if this is an individual file
if(node.isDirectory===false&&node.artifact){
const art=node.artifact;

// File-specific header
html+=`<div class="data-section">`;
html+=`<div class="data-label">Artifact File</div>`;
html+=`<div class="data-value" style="word-break:break-all;font-size:11px">${node.name}</div>`;
html+=`</div>`;

// File details
html+=`<div class="data-section">`;
html+=`<div class="data-label">Type</div>`;
html+=`<div class="data-value" style="color:${getColorForExt(node.ext)}">.${node.ext}</div>`;
html+=`<div style="margin-top:8px">`;
html+=`<div class="data-label">Size</div>`;
html+=`<div class="data-value">${formatSize(node.size)}</div>`;
html+=`</div>`;
html+=`</div>`;

// Full path
html+=`<div class="data-section">`;
html+=`<div class="data-label">Full Path</div>`;
html+=`<div style="font-size:9px;color:#6b8a96;word-break:break-all;margin-top:4px">${art.path}</div>`;
html+=`</div>`;

// Metadata if available
if(art.width||art.height||art.duration){
html+=`<div class="data-section">`;
html+=`<div class="data-label">Media Info</div>`;
if(art.width&&art.height){
html+=`<div style="color:#4dd9cc;font-size:11px;margin-top:4px">${art.width}√ó${art.height} px</div>`;
}
if(art.duration){
html+=`<div style="color:#4dd9cc;font-size:11px;margin-top:4px">Duration: ${art.duration}s</div>`;
}
html+=`</div>`;
}

// Provenance if available
if(art.source||art.generator){
html+=`<div class="data-section">`;
html+=`<div class="data-label">Provenance</div>`;
if(art.source){
html+=`<div style="font-size:9px;color:#6b8a96;margin-top:4px">Source: ${art.source}</div>`;
}
if(art.generator){
html+=`<div style="font-size:9px;color:#6b8a96;margin-top:4px">Generator: ${art.generator}</div>`;
}
html+=`</div>`;
}

}else{
// COMPACT DASHBOARD VIEW

// Taxonomy Hierarchy Path (Kingdom ‚Üí Phylum ‚Üí Class ‚Üí Order)
html+=`<div style="background:rgba(77,217,204,0.05);padding:8px;margin-bottom:10px;border-radius:4px">`;
html+=`<div style="font-size:8px;color:#6b8a96;text-transform:uppercase;margin-bottom:4px">TAXONOMY</div>`;
html+=`<div style="font-size:10px;color:#4dd9cc;line-height:1.6">`;

// Build hierarchy from path
if(STATE.path.length>0){
const taxonomyLevels=['Kingdom','Phylum','Class','Order','Family','Genus','Species'];
STATE.path.forEach((n,i)=>{
if(i<taxonomyLevels.length){
const isLast=n===node;
const style=isLast?'color:#e8b849;font-weight:bold':'color:#6b8a96';
html+=`<div style="${style};font-size:${isLast?'11px':'9px'}">`;
html+=`<span style="opacity:0.6">${taxonomyLevels[i]}:</span> ${n.name}`;
html+=`</div>`;
}
});
}else{
html+=`<div style="color:#e8b849;font-weight:bold">${node.name}</div>`;
}
html+=`</div></div>`;

// COMPACT METRICS GRID
const massInMB=(node.totalBytes/(1024*1024)).toFixed(1);

html+=`<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px">`;

// Volume
html+=`<div style="background:rgba(77,217,204,0.08);padding:8px;border-radius:4px">`;
html+=`<div style="font-size:8px;color:#6b8a96">VOLUME</div>`;
html+=`<div style="font-size:16px;color:#4dd9cc;font-weight:bold">${node.totalFiles.toLocaleString()}</div>`;
html+=`<div style="font-size:8px;color:#6b8a96">files</div>`;
html+=`</div>`;

// Mass
html+=`<div style="background:rgba(232,184,73,0.08);padding:8px;border-radius:4px">`;
html+=`<div style="font-size:8px;color:#6b8a96">MASS</div>`;
html+=`<div style="font-size:16px;color:#e8b849;font-weight:bold">${formatSize(node.totalBytes)}</div>`;
html+=`<div style="font-size:8px;color:#6b8a96">${massInMB} MB</div>`;
html+=`</div>`;

html+=`</div>`;

// Dominant Species + % of Parent
html+=`<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:10px">`;

// Dominant species
if(node.dominantSpecies){
html+=`<div style="background:rgba(157,123,232,0.08);padding:8px;border-radius:4px">`;
html+=`<div style="font-size:8px;color:#6b8a96">DOMINANT</div>`;
html+=`<div style="font-size:14px;color:${node.dominantColor};font-weight:bold">.${node.dominantSpecies}</div>`;
html+=`<div style="font-size:8px;color:#6b8a96">${node.dominantPct}%</div>`;
html+=`</div>`;
}else{
html+=`<div></div>`;
}

// % of parent
if(node.percentage){
html+=`<div style="background:rgba(107,189,143,0.08);padding:8px;border-radius:4px">`;
html+=`<div style="font-size:8px;color:#6b8a96">OF PARENT</div>`;
html+=`<div style="font-size:16px;color:#6bbd8f;font-weight:bold">${node.percentage}%</div>`;
html+=`<div style="font-size:8px;color:#6b8a96">share</div>`;
html+=`</div>`;
}

html+=`</div>`;

// DENSITY - Compact 3-column grid
if(node.density){
html+=`<div style="font-size:8px;color:#6b8a96;margin:10px 0 4px 0">DENSITY</div>`;
html+=`<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:6px;margin-bottom:10px">`;

// Files/Level
html+=`<div style="background:rgba(157,123,232,0.06);padding:6px;border-radius:3px;text-align:center">`;
html+=`<div style="font-size:14px;color:#9d7be8;font-weight:bold">${node.density.filesPerLevel.toFixed(0)}</div>`;
html+=`<div style="font-size:7px;color:#6b8a96">files/lvl</div>`;
html+=`</div>`;

// Depth Span
html+=`<div style="background:rgba(157,123,232,0.06);padding:6px;border-radius:3px;text-align:center">`;
html+=`<div style="font-size:14px;color:#9d7be8;font-weight:bold">${node.density.depthSpan}</div>`;
html+=`<div style="font-size:7px;color:#6b8a96">levels</div>`;
html+=`</div>`;

// Brightness (visual encoding)
const globalAvgDensity=100;
const densityRatio=Math.log(node.density.filesPerLevel+1)/Math.log(globalAvgDensity+1);
const brightnessFactor=Math.min(1.4,Math.max(0.6,0.8+densityRatio*0.4));
const brightnessIcon=brightnessFactor>1.1?'‚òÄÔ∏è':brightnessFactor<0.9?'üåô':'‚õÖ';

html+=`<div style="background:rgba(157,123,232,0.06);padding:6px;border-radius:3px;text-align:center">`;
html+=`<div style="font-size:14px;color:#9d7be8;font-weight:bold">${brightnessIcon}</div>`;
html+=`<div style="font-size:7px;color:#6b8a96">${brightnessFactor.toFixed(1)}√ó</div>`;
html+=`</div>`;

html+=`</div>`;
}

// SPECIES - Visual bars (top 5 only)
if(node.species&&Object.keys(node.species).length>0){
html+=`<div style="font-size:8px;color:#6b8a96;margin:10px 0 4px 0">SPECIES (Top 5)</div>`;

const sorted=Object.entries(node.species).sort((a,b)=>b[1].count-a[1].count).slice(0,5);
sorted.forEach(([type,data])=>{
const pct=node.totalFiles>0?(data.count/node.totalFiles*100):0;
const barWidth=Math.max(5,pct);

html+=`<div style="margin-bottom:4px">`;
html+=`<div style="display:flex;justify-content:space-between;font-size:9px;margin-bottom:2px">`;
html+=`<span style="color:${data.color}">.${type}</span>`;
html+=`<span style="color:#6b8a96">${data.count}</span>`;
html+=`</div>`;
html+=`<div style="background:rgba(107,138,150,0.1);height:4px;border-radius:2px;overflow:hidden">`;
html+=`<div style="background:${data.color};height:100%;width:${barWidth}%"></div>`;
html+=`</div>`;
html+=`</div>`;
});
}

// Divider before children list
html+=`<div style="border-top:1px solid rgba(77,217,204,0.15);margin:12px 0 8px 0"></div>`;

// Children - Ultra compact list
if(node.children.length>0){
const hasFiles=node.children.some(cid=>STATE.nodeMap[cid]&&!STATE.nodeMap[cid].isDirectory);
const icon=hasFiles?'üìÑ':'üìÅ';
html+=`<div style="font-size:8px;color:#6b8a96;margin-bottom:6px">${icon} ${node.children.length} ITEMS</div>`;
html+=`<div style="max-height:200px;overflow-y:auto;font-size:9px">`;
node.children.slice(0,15).forEach(cid=>{
const child=STATE.nodeMap[cid];
if(!child)return;
const childIcon=child.isDirectory?'üìÅ':'üìÑ';
const size=child.isDirectory?`${child.totalFiles}`:formatSize(child.size||0);
html+=`<div onclick="viewNode('${child.id}')" style="cursor:pointer;padding:4px 0;display:flex;justify-content:space-between;border-bottom:1px solid rgba(77,217,204,0.05);align-items:center">`;
html+=`<span style="color:#4dd9cc;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;padding-right:8px">${childIcon} ${child.name}</span>`;
html+=`<span style="color:#6b8a96;font-size:8px;white-space:nowrap">${size}</span>`;
html+=`</div>`;
});
if(node.children.length>15){
html+=`<div style="font-size:8px;color:#6b8a96;margin-top:6px;text-align:center;padding:4px">+${node.children.length-15} more</div>`;
}
html+=`</div>`;
}

}

document.getElementById('territoryContent').innerHTML=html;
}

function formatSize(bytes){
if(!bytes)return '0 B';
if(bytes<1024)return bytes+' B';
if(bytes<1024*1024)return(bytes/1024).toFixed(1)+' KB';
if(bytes<1024*1024*1024)return(bytes/(1024*1024)).toFixed(1)+' MB';
return(bytes/(1024*1024*1024)).toFixed(2)+' GB';
}

function calculateCellArea(cell){
let area=0;
for(let i=0;i<cell.angles.length;i++){
const j=(i+1)%cell.angles.length;
const x1=cell.cx+Math.cos(cell.angles[i])*cell.radii[i];
const y1=cell.cy+Math.sin(cell.angles[i])*cell.radii[i];
const x2=cell.cx+Math.cos(cell.angles[j])*cell.radii[j];
const y2=cell.cy+Math.sin(cell.angles[j])*cell.radii[j];
area+=x1*y2-x2*y1;
}
return Math.abs(area)/2;
}

function resize(){
W = window.innerWidth / 2; // Split screen
H = window.innerHeight;

// Resize both canvases
CAN_VORONOI.width = W * DPR;
CAN_VORONOI.height = H * DPR;
CAN_VORONOI.style.width = W + 'px';
CAN_VORONOI.style.height = H + 'px';

CAN_SEDIMENT.width = W * DPR;
CAN_SEDIMENT.height = H * DPR;
CAN_SEDIMENT.style.width = W + 'px';
CAN_SEDIMENT.style.height = H + 'px';

// Legacy
CAN.width = W * DPR;
CAN.height=H*DPR;
CAN.style.width=W+'px';
CAN.style.height=H+'px';

if(STATE.current){
if(STATE.current===STATE.root){
viewRoot();
}else{
viewNode(STATE.current.id);
}
}
}

CAN.addEventListener('mousemove',e=>{
const rect=CAN.getBoundingClientRect();
const canvasX=e.clientX-rect.left;
const canvasY=e.clientY-rect.top;

// Transform to world coordinates
const mx=(canvasX-STATE.camera.tx)/STATE.camera.scale;
const my=(canvasY-STATE.camera.ty)/STATE.camera.scale;

if(!STATE.current)return;

// Find hovered cell
STATE.hoveredNode=null;
const children=STATE.current.children.map(id=>STATE.nodeMap[id]);
for(const ch of children){
if(ch.cell&&pointInCell(mx,my,ch.cell)){
STATE.hoveredNode=ch;
break;
}
}

render();
});

// Mouse wheel zoom
CAN.addEventListener('wheel',e=>{
e.preventDefault();

const rect=CAN.getBoundingClientRect();
const canvasX=e.clientX-rect.left;
const canvasY=e.clientY-rect.top;

// Convert canvas coords to world coords
const worldX=(canvasX-STATE.camera.tx)/STATE.camera.scale;
const worldY=(canvasY-STATE.camera.ty)/STATE.camera.scale;

// Zoom in/out
const zoomFactor=e.deltaY<0?1.15:0.87;
const newScale=Math.max(0.5,Math.min(20,STATE.camera.scale*zoomFactor));

// Adjust translation to zoom toward mouse position
STATE.camera.scale=newScale;
STATE.camera.tx=canvasX-worldX*newScale;
STATE.camera.ty=canvasY-worldY*newScale;
STATE.camera.targetScale=newScale;
STATE.camera.targetTx=STATE.camera.tx;
STATE.camera.targetTy=STATE.camera.ty;

render();
},{passive:false});

CAN.addEventListener('click',e=>{
const rect=CAN.getBoundingClientRect();
const canvasX=e.clientX-rect.left;
const canvasY=e.clientY-rect.top;

// Transform click to world coordinates
const mx=(canvasX-STATE.camera.tx)/STATE.camera.scale;
const my=(canvasY-STATE.camera.ty)/STATE.camera.scale;

if(!STATE.current)return;

const children=STATE.current.children.map(id=>STATE.nodeMap[id]);
let clicked=null;

children.forEach(ch=>{
if(ch.cell&&pointInCell(mx,my,ch.cell)){
clicked=ch;
}
});

if(clicked){
// Handle mode-specific actions
if(currentMode === 'flag'){
  // Flag mode: Create crossing flow
  flaggedNodes.add(clicked.id);
  crossingFlows.push({
    fromNode: clicked,
    toNode: clicked, // Same node in sediment view
    mode: 'flag',
    timestamp: Math.random()
  });
  document.getElementById('hudFlags').textContent = flaggedNodes.size;
  render();
} else if(currentMode === 'tag'){
  // Tag mode: Create crossing flow
  taggedNodes.add(clicked.id);
  crossingFlows.push({
    fromNode: clicked,
    toNode: clicked,
    mode: 'tag',
    timestamp: Math.random()
  });
  document.getElementById('hudTags').textContent = taggedNodes.size;
  render();
} else {
  // Explore mode: drill down
  viewNode(clicked.id);
}
}else{
// Clicked outside children - check if in parent, go up
if(STATE.current.cell&&pointInCell(mx,my,STATE.current.cell)){
// Clicked in parent area but not on children - go up
if(STATE.path.length>1){
const parent=STATE.path[STATE.path.length-2];
viewNode(parent.id);
}
}else if(!STATE.current.cell&&STATE.path.length===1){
// At root, clicked outside - stay here
return;
}else{
// Clicked outside everything - go up
if(STATE.path.length>1){
const parent=STATE.path[STATE.path.length-2];
viewNode(parent.id);
}
}
}
});

// SEDIMENT CANVAS CLICK - Navigate by clicking strata
CAN_SEDIMENT.addEventListener('click', e => {
  const rect = CAN_SEDIMENT.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  
  if(!STATE.current) return;
  
  const children = STATE.current.children.map(id => STATE.nodeMap[id]);
  let clicked = null;
  
  // Check which stratum was clicked
  children.forEach(layer => {
    if(layer.sedimentBounds){
      const b = layer.sedimentBounds;
      if(mx >= b.xLeft && mx <= b.xRight && my >= b.yTop && my <= b.yBottom){
        clicked = layer;
      }
    }
  });
  
  if(clicked){
    // Clicked a layer - drill down
    viewNode(clicked.id);
  } else if(STATE.path.length > 1){
    // Clicked outside - go up
    const parent = STATE.path[STATE.path.length - 2];
    viewNode(parent.id);
  }
});

// SEDIMENT CANVAS HOVER - Synchronized highlighting
CAN_SEDIMENT.addEventListener('mousemove', e => {
  const rect = CAN_SEDIMENT.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  
  if(!STATE.current) return;
  
  const children = STATE.current.children.map(id => STATE.nodeMap[id]);
  let hovered = null;
  
  // Check which stratum is hovered
  children.forEach(layer => {
    if(layer.sedimentBounds){
      const b = layer.sedimentBounds;
      if(mx >= b.xLeft && mx <= b.xRight && my >= b.yTop && my <= b.yBottom){
        hovered = layer;
      }
    }
  });
  
  // Update hover state (synchronized across both views)
  if(hovered !== STATE.hoveredNode){
    STATE.hoveredNode = hovered;
    render(); // Update both views
  }
  
  // Update cursor
  CAN_SEDIMENT.style.cursor = hovered ? 'pointer' : 'default';
});

// SEDIMENT CANVAS SCROLL - Independent zoom
CAN_SEDIMENT.addEventListener('wheel', e => {
  e.preventDefault();
  
  const rect = CAN_SEDIMENT.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  const newScale = Math.max(0.5, Math.min(5, STATE.sedimentCamera.targetScale * zoomFactor));
  
  // Zoom towards mouse position
  const worldX = (mouseX - STATE.sedimentCamera.targetTx) / STATE.sedimentCamera.targetScale;
  const worldY = (mouseY - STATE.sedimentCamera.targetTy) / STATE.sedimentCamera.targetScale;
  
  STATE.sedimentCamera.targetScale = newScale;
  STATE.sedimentCamera.targetTx = mouseX - worldX * newScale;
  STATE.sedimentCamera.targetTy = mouseY - worldY * newScale;
  
  animateSedimentCamera();
}, {passive: false});

// Sediment camera animation (independent)
function animateSedimentCamera(){
  if(STATE.sedimentAnimating) return;
  STATE.sedimentAnimating = true;
  
  const startTime = Date.now();
  const duration = 300;
  const startScale = STATE.sedimentCamera.scale;
  const startTx = STATE.sedimentCamera.tx;
  const startTy = STATE.sedimentCamera.ty;
  
  function step(){
    const elapsed = Date.now() - startTime;
    const t = Math.min(1, elapsed / duration);
    const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    
    STATE.sedimentCamera.scale = startScale + (STATE.sedimentCamera.targetScale - startScale) * ease;
    STATE.sedimentCamera.tx = startTx + (STATE.sedimentCamera.targetTx - startTx) * ease;
    STATE.sedimentCamera.ty = startTy + (STATE.sedimentCamera.targetTy - startTy) * ease;
    
    renderSediment();
    
    if(t < 1){
      requestAnimationFrame(step);
    } else {
      STATE.sedimentAnimating = false;
    }
  }
  
  step();
}

function populateSpeciesDropdown(){
// Collect all species from nodes
STATE.allSpecies.clear();
STATE.nodes.forEach(node=>{
if(node.species){
Object.keys(node.species).forEach(ext=>STATE.allSpecies.add(ext));
}
});

// Populate dropdown
const select=document.getElementById('speciesFilter');
select.innerHTML='<option value="all">All Media Types</option>';

const sortedSpecies=Array.from(STATE.allSpecies).sort();
sortedSpecies.forEach(ext=>{
const color=getColorForExt(ext);
select.innerHTML+=`<option value="${ext}" style="color:${color}">.${ext}</option>`;
});
}

function applySpeciesFilter(){
const select=document.getElementById('speciesFilter');
STATE.speciesFilter=select.value;

// Update status
const status=document.getElementById('filterStatus');
if(STATE.speciesFilter==='all'){
status.textContent='Showing all territories';
}else{
status.textContent=`Filtering: .${STATE.speciesFilter} only`;
status.style.color='#e8b849';
}

render();
}

function nodeMatchesFilter(node){
if(STATE.speciesFilter==='all')return true;
if(!node.species)return false;

// Node matches if it contains the filtered species
return node.species.hasOwnProperty(STATE.speciesFilter);
}

function pointInCell(x,y,cell){
let inside=false;
const {cx,cy,angles,radii}=cell;

for(let i=0,j=angles.length-1;i<angles.length;j=i++){
const xi=cx+Math.cos(angles[i])*radii[i];
const yi=cy+Math.sin(angles[i])*radii[i];
const xj=cx+Math.cos(angles[j])*radii[j];
const yj=cy+Math.sin(angles[j])*radii[j];

if(((yi>y)!==(yj>y))&&(x<(xj-xi)*(y-yi)/(yj-yi)+xi)){
inside=!inside;
}
}
return inside;
}

window.addEventListener('resize',resize);

// Keyboard navigation
window.addEventListener('keydown',e=>{
if(!STATE.current)return;

// Escape or Backspace: Go to parent
if(e.key==='Escape'||e.key==='Backspace'){
if(STATE.path.length>1){
const parent=STATE.path[STATE.path.length-2];
viewNode(parent.id);
}
e.preventDefault();
}

// Arrow Up: Go to parent
if(e.key==='ArrowUp'&&!e.shiftKey){
if(STATE.path.length>1){
const parent=STATE.path[STATE.path.length-2];
viewNode(parent.id);
}
e.preventDefault();
}

// Arrow Down: Go to first child
if(e.key==='ArrowDown'&&!e.shiftKey){
if(STATE.current.children.length>0){
const firstChild=STATE.nodeMap[STATE.current.children[0]];
if(firstChild)viewNode(firstChild.id);
}
e.preventDefault();
}

// Arrow Left/Right: Navigate siblings
if(e.key==='ArrowLeft'||e.key==='ArrowRight'){
if(STATE.path.length>1){
const parent=STATE.path[STATE.path.length-2];
const siblings=parent.children;
const currentIdx=siblings.indexOf(STATE.current.id);

if(e.key==='ArrowLeft'&&currentIdx>0){
viewNode(siblings[currentIdx-1]);
}else if(e.key==='ArrowRight'&&currentIdx<siblings.length-1){
viewNode(siblings[currentIdx+1]);
}
}
e.preventDefault();
}

// H key: Go home (root)
if(e.key==='h'||e.key==='H'){
viewRoot();
}
});

function zoomToBoundary(boundary){
// Zoom to fit a circular boundary
const diameter=boundary.radius*2;

// Target: fill 70% of viewport
const targetSize=Math.min(W,H)*0.7;
const scale=targetSize/diameter;

STATE.camera.targetScale=scale;
STATE.camera.targetTx=(W/2-boundary.x*scale);
STATE.camera.targetTy=(H/2-boundary.y*scale);
animateCameraToTarget();
}

function zoomToCell(cell){
// Calculate bounding box of cell
let minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity;
for(let i=0;i<cell.angles.length;i++){
const px=cell.cx+Math.cos(cell.angles[i])*cell.radii[i];
const py=cell.cy+Math.sin(cell.angles[i])*cell.radii[i];
minX=Math.min(minX,px);
maxX=Math.max(maxX,px);
minY=Math.min(minY,py);
maxY=Math.max(maxY,py);
}

const cellW=maxX-minX;
const cellH=maxY-minY;
const cellCX=(minX+maxX)/2;
const cellCY=(minY+maxY)/2;

// Target: fill 70% of viewport
const targetW=W*0.7;
const targetH=H*0.7;
const scaleX=targetW/cellW;
const scaleY=targetH/cellH;
const scale=Math.min(scaleX,scaleY);

// Calculate translation to center
const targetCX=W/2;
const targetCY=H/2;

STATE.camera.targetScale=scale;
STATE.camera.targetTx=(targetCX-cellCX*scale);
STATE.camera.targetTy=(targetCY-cellCY*scale);

animateCameraToTarget();
}

function animateCameraToTarget(){
if(STATE.animating)return;
STATE.animating=true;

const duration=500; // ms
const startTime=Date.now();
const startScale=STATE.camera.scale;
const startTx=STATE.camera.tx;
const startTy=STATE.camera.ty;

function step(){
const elapsed=Date.now()-startTime;
const t=Math.min(elapsed/duration,1);

// Smooth easing
const ease=t<0.5?2*t*t:1-Math.pow(-2*t+2,2)/2;

STATE.camera.scale=startScale+(STATE.camera.targetScale-startScale)*ease;
STATE.camera.tx=startTx+(STATE.camera.targetTx-startTx)*ease;
STATE.camera.ty=startTy+(STATE.camera.targetTy-startTy)*ease;

render();

if(t<1){
requestAnimationFrame(step);
}else{
STATE.animating=false;
}
}

step();
}

window.addEventListener('load',()=>{
resize();
// Auto-load real data on start
loadRealData();
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// 4B NAVIGATION HELPERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function navParent(){
  if(STATE.current && STATE.current.parent){
    const parent = STATE.nodeMap[STATE.current.parent];
    if(parent) viewNode(parent.id);
  }
}

function navChild(){
  if(STATE.current && STATE.current.children.length > 0){
    viewNode(STATE.current.children[0]);
  }
}

function navPrevSibling(){
  if(!STATE.current || !STATE.current.parent) return;
  const parent = STATE.nodeMap[STATE.current.parent];
  if(!parent) return;
  const siblings = parent.children;
  const idx = siblings.indexOf(STATE.current.id);
  if(idx > 0){
    viewNode(siblings[idx - 1]);
  }
}

function navNextSibling(){
  if(!STATE.current || !STATE.current.parent) return;
  const parent = STATE.nodeMap[STATE.current.parent];
  if(!parent) return;
  const siblings = parent.children;
  const idx = siblings.indexOf(STATE.current.id);
  if(idx < siblings.length - 1){
    viewNode(siblings[idx + 1]);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MODE SYSTEM & LAYER TOGGLING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
let currentMode = 'explore';
let showVoronoiLayer = true;
let showSedimentLayer = false;
let flaggedNodes = new Set();
let taggedNodes = new Set();
let crossingFlows = []; // Sankey-style flows between views
let pulseTime = 0; // Animation time for pulses

function setMode(mode){
  currentMode = mode;
  
  // Update UI
  document.querySelectorAll('[id^="mode"]').forEach(btn => btn.classList.remove('active'));
  document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
  
  const modeNames = { 
    explore: '‚õè EXPLORE', 
    flag: '‚öë FLAG', 
    tag: '‚úé TAG', 
    measure: 'üìè MEASURE' 
  };
  document.getElementById('hudMode').textContent = modeNames[mode];
  
  const overlay = document.getElementById('modeOverlay');
  overlay.className = 'mode-overlay';
  if (mode !== 'explore') {
    overlay.classList.add(mode + '-mode');
  }
  
  console.log(`Mode changed to: ${mode}`);
}

function toggleLayer(layer){
  if(layer === 'voronoi'){
    showVoronoiLayer = !showVoronoiLayer;
    document.getElementById('toggleVoronoi').classList.toggle('active');
  } else if(layer === 'sediment'){
    showSedimentLayer = !showSedimentLayer;
    document.getElementById('toggleSediment').classList.toggle('active');
  }
  
  // Update HUD layer indicator
  let layerText = '';
  if(showVoronoiLayer && showSedimentLayer) layerText = 'V+S';
  else if(showVoronoiLayer) layerText = 'V';
  else if(showSedimentLayer) layerText = 'S';
  else layerText = '‚Äî';
  document.getElementById('hudLayers').textContent = layerText;
  
  console.log(`Layers: Voronoi=${showVoronoiLayer}, Sediment=${showSedimentLayer}`);
  render();
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if(e.key === 'e' || e.key === 'E') setMode('explore');
  if(e.key === 'f' || e.key === 'F') setMode('flag');
  if(e.key === 't' || e.key === 'T') setMode('tag');
  if(e.key === 'm' || e.key === 'M') setMode('measure');
  if(e.key === 'v' || e.key === 'V') toggleLayer('voronoi');
  if(e.key === 's' || e.key === 'S') toggleLayer('sediment');
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FILE TREE PANEL - Collapsible directory browser
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
function toggleFileTree(){
  STATE.showFileTree = !STATE.showFileTree;
  const panel = document.getElementById('fileTreePanel');
  panel.style.display = STATE.showFileTree ? 'block' : 'none';
  
  if(STATE.showFileTree){
    buildFileTree();
  }
}

function buildFileTree(){
  const content = document.getElementById('fileTreeContent');
  if(!STATE.root) return;
  
  let html = '';
  
  function renderNode(node, indent = 0){
    const isCurrent = node === STATE.current;
    const hasChildren = node.children && node.children.length > 0;
    const fileCount = node.totalFiles || 0;
    const sizeMB = ((node.totalBytes || 0) / 1024 / 1024).toFixed(1);
    
    const color = node.dominantColor || DEPTH_COLORS[node.depth % DEPTH_COLORS.length];
    const arrow = hasChildren ? '‚ñ∏' : '‚Ä¢';
    const style = isCurrent ? `background:rgba(77,217,204,0.2);font-weight:bold` : '';
    
    html += `<div style="padding:4px 0 4px ${indent * 12}px;cursor:pointer;${style}" onclick="viewNode('${node.id}')">`;
    html += `<span style="color:${color}">${arrow} ${node.name}</span>`;
    html += ` <span style="color:#6b8a96;font-size:9px">(${fileCount} ‚Ä¢ ${sizeMB}MB)</span>`;
    html += `</div>`;
    
    if(hasChildren && (isCurrent || indent < 2)){
      node.children.forEach(cid => {
        const child = STATE.nodeMap[cid];
        if(child) renderNode(child, indent + 1);
      });
    }
  }
  
  renderNode(STATE.root);
  content.innerHTML = html;
}

console.log('üî´üî´ DOUBLE BARREL: Voronoi + Sediment Split View');
console.log('');
console.log('üì∫ SPLIT SCREEN LAYOUT:');
console.log('  LEFT:  üåä Voronoi tessellation (Lloyd\'s relaxation)');
console.log('  RIGHT: üèîÔ∏è Sediment strata (classic horizontal layers)');
console.log('  SYNC:  Same data, same navigation, two views');
console.log('');
console.log('‚õè FULL MODE SYSTEM:');
console.log('  E = Explore mode');
console.log('  F = Flag mode');
console.log('  T = Tag mode');
console.log('  M = Measure mode');
console.log('');
console.log('‚å®Ô∏è NAVIGATION:');
console.log('  Arrows = Navigate hierarchy');
console.log('  H = Home (root)');
console.log('  Esc = Ascend');
console.log('  V/S = Toggle individual views');
console.log('');
console.log('üìä UNIFIED INTERFACE:');
console.log('  ‚Ä¢ Single data source (sys/primitive.jsonl)');
console.log('  ‚Ä¢ Synchronized navigation');
console.log('  ‚Ä¢ 4B control surfaces (left strip + HUD + core sample)');
console.log('  ‚Ä¢ Both views update simultaneously');

</script>

</body></html>
